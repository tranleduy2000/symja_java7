package org.matheclipse.core.reflection.system.rules;

import org.matheclipse.core.interfaces.IAST;

import static org.matheclipse.core.expression.F.$p;
import static org.matheclipse.core.expression.F.Abs;
import static org.matheclipse.core.expression.F.And;
import static org.matheclipse.core.expression.F.BernoulliB;
import static org.matheclipse.core.expression.F.C0;
import static org.matheclipse.core.expression.F.C1;
import static org.matheclipse.core.expression.F.C1D2;
import static org.matheclipse.core.expression.F.C2;
import static org.matheclipse.core.expression.F.CN1;
import static org.matheclipse.core.expression.F.Condition;
import static org.matheclipse.core.expression.F.Cot;
import static org.matheclipse.core.expression.F.Direction;
import static org.matheclipse.core.expression.F.E;
import static org.matheclipse.core.expression.F.Equal;
import static org.matheclipse.core.expression.F.EvenQ;
import static org.matheclipse.core.expression.F.Factorial;
import static org.matheclipse.core.expression.F.Greater;
import static org.matheclipse.core.expression.F.HarmonicNumber;
import static org.matheclipse.core.expression.F.IInit;
import static org.matheclipse.core.expression.F.ISet;
import static org.matheclipse.core.expression.F.ISetDelayed;
import static org.matheclipse.core.expression.F.If;
import static org.matheclipse.core.expression.F.IntegerQ;
import static org.matheclipse.core.expression.F.Limit;
import static org.matheclipse.core.expression.F.List;
import static org.matheclipse.core.expression.F.Log;
import static org.matheclipse.core.expression.F.Module;
import static org.matheclipse.core.expression.F.Negate;
import static org.matheclipse.core.expression.F.Negative;
import static org.matheclipse.core.expression.F.Noo;
import static org.matheclipse.core.expression.F.NumberQ;
import static org.matheclipse.core.expression.F.Pi;
import static org.matheclipse.core.expression.F.Plus;
import static org.matheclipse.core.expression.F.Positive;
import static org.matheclipse.core.expression.F.Power;
import static org.matheclipse.core.expression.F.Rule;
import static org.matheclipse.core.expression.F.Set;
import static org.matheclipse.core.expression.F.Symbol;
import static org.matheclipse.core.expression.F.Tan;
import static org.matheclipse.core.expression.F.Times;
import static org.matheclipse.core.expression.F.a;
import static org.matheclipse.core.expression.F.a_;
import static org.matheclipse.core.expression.F.m;
import static org.matheclipse.core.expression.F.oo;
import static org.matheclipse.core.expression.F.s;
import static org.matheclipse.core.expression.F.v;
import static org.matheclipse.core.expression.F.x;
import static org.matheclipse.core.expression.F.x_;
import static org.matheclipse.core.expression.F.y;

/**
 * <p>Generated by <code>org.matheclipse.core.preprocessor.RulePreprocessor</code>.</p>
 * <p>See GIT repository at: <a href="https://bitbucket.org/axelclk/symja_android_library">bitbucket.org/axelclk/symja_android_library under the tools directory</a>.</p>
 */
public interface LimitRules {
  /**
   * <ul>
   * <li>index 0 - number of equal rules in <code>RULES</code></li>
	 * </ul>
	 */
  final public static int[] SIZES = { 4, 13 };

  final public static IAST RULES = List(
    IInit(Limit, SIZES),
    // Limit(x_^m_NumberQ,x_Symbol->Infinity):=Infinity/;Positive(m)
    ISetDelayed(Limit(Power(x_,$p(m,NumberQ)),Rule($p(x,Symbol),oo)),
      Condition(oo,Positive(m))),
    // Limit(x_^m_NumberQ,x_Symbol->Infinity):=0/;Negative(m)
    ISetDelayed(Limit(Power(x_,$p(m,NumberQ)),Rule($p(x,Symbol),oo)),
      Condition(C0,Negative(m))),
    // Limit(m_NumberQ^x_,x_Symbol->Infinity):=If(m>1,Infinity,If(m==1,1,0))/;Positive(m)
    ISetDelayed(Limit(Power($p(m,NumberQ),x_),Rule($p(x,Symbol),oo)),
      Condition(If(Greater(m,C1),oo,If(Equal(m,C1),C1,C0)),Positive(m))),
    // Limit(m_NumberQ^(-x_),x_Symbol->Infinity):=0/;m>1
    ISetDelayed(Limit(Power($p(m,NumberQ),Negate(x_)),Rule($p(x,Symbol),oo)),
      Condition(C0,Greater(m,C1))),
    // Limit(E^x_,x_Symbol->Infinity):=Infinity
    ISetDelayed(Limit(Power(E,x_),Rule($p(x,Symbol),oo)),
      oo),
    // Limit(E^x_,x_Symbol->-Infinity):=0
    ISetDelayed(Limit(Power(E,x_),Rule($p(x,Symbol),Negate(oo))),
      C0),
    // Limit(Log(x_),x_Symbol->0)=-Infinity
    ISet(Limit(Log(x_),Rule($p(x,Symbol),C0)),
      Noo),
    // Limit(Log(x_),x_Symbol->Infinity)=Infinity
    ISet(Limit(Log(x_),Rule($p(x,Symbol),oo)),
      oo),
    // Limit((1+1/x_)^x_,x_Symbol->Infinity)=E
    ISet(Limit(Power(Plus(C1,Power(x_,-1)),x_),Rule($p(x,Symbol),oo)),
      E),
    // Limit((1+a_/x_)^x_,x_Symbol->Infinity)=E^a/;FreeQ(a,x)
    ISet(Limit(Power(Plus(C1,Times(a_,Power(x_,-1))),x_),Rule($p(x,Symbol),oo)),
      Power(E,a)),
    // Limit(HarmonicNumber(y_Symbol,s_IntegerQ),x_Symbol->Infinity):=Module({v=s/2},((-1)^(v+1)*(2*Pi)^(2*v)*BernoulliB(2*v))/(2*(2*v)!))/;EvenQ(s)&&Positive(s)
    ISetDelayed(Limit(HarmonicNumber($p(y,Symbol),$p(s,IntegerQ)),Rule($p(x,Symbol),oo)),
      Condition(Module(List(Set(v,Times(C1D2,s))),Times(Power(CN1,Plus(v,C1)),Power(Times(C2,Pi),Times(C2,v)),BernoulliB(Times(C2,v)),Power(Times(C2,Factorial(Times(C2,v))),-1))),And(EvenQ(s),Positive(s)))),
    // Limit(x_/Abs(x_),x_Symbol->0,Direction->1):=-1
    ISetDelayed(Limit(Times(x_,Power(Abs(x_),-1)),Rule($p(x,Symbol),C0),Rule(Direction,C1)),
      CN1),
    // Limit(x_/Abs(x_),x_Symbol->0,Direction->-1):=1
    ISetDelayed(Limit(Times(x_,Power(Abs(x_),-1)),Rule($p(x,Symbol),C0),Rule(Direction,CN1)),
      C1),
    // Limit(Tan(x_),x_Symbol->Pi/2,Direction->1):=Infinity
    ISetDelayed(Limit(Tan(x_),Rule($p(x,Symbol),Times(C1D2,Pi)),Rule(Direction,C1)),
      oo),
    // Limit(Tan(x_),x_Symbol->Pi/2,Direction->-1):=-Infinity
    ISetDelayed(Limit(Tan(x_),Rule($p(x,Symbol),Times(C1D2,Pi)),Rule(Direction,CN1)),
      Negate(oo)),
    // Limit(Cot(x_),x_Symbol->0,Direction->1):=-Infinity
    ISetDelayed(Limit(Cot(x_),Rule($p(x,Symbol),C0),Rule(Direction,C1)),
      Negate(oo)),
    // Limit(Cot(x_),x_Symbol->0,Direction->-1):=Infinity
    ISetDelayed(Limit(Cot(x_),Rule($p(x,Symbol),C0),Rule(Direction,CN1)),
      oo)
  );
}