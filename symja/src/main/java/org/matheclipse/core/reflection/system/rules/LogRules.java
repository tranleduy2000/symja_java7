package org.matheclipse.core.reflection.system.rules;

import org.matheclipse.core.interfaces.IAST;

import static org.matheclipse.core.expression.F.$p;
import static org.matheclipse.core.expression.F.ArcCsch;
import static org.matheclipse.core.expression.F.C0;
import static org.matheclipse.core.expression.F.C1;
import static org.matheclipse.core.expression.F.C1D2;
import static org.matheclipse.core.expression.F.C2;
import static org.matheclipse.core.expression.F.CC;
import static org.matheclipse.core.expression.F.CComplexInfinity;
import static org.matheclipse.core.expression.F.CI;
import static org.matheclipse.core.expression.F.CN1;
import static org.matheclipse.core.expression.F.CNI;
import static org.matheclipse.core.expression.F.CSqrt5;
import static org.matheclipse.core.expression.F.DirectedInfinity;
import static org.matheclipse.core.expression.F.E;
import static org.matheclipse.core.expression.F.GoldenRatio;
import static org.matheclipse.core.expression.F.IInit;
import static org.matheclipse.core.expression.F.ISet;
import static org.matheclipse.core.expression.F.ISetDelayed;
import static org.matheclipse.core.expression.F.Indeterminate;
import static org.matheclipse.core.expression.F.IntegerQ;
import static org.matheclipse.core.expression.F.List;
import static org.matheclipse.core.expression.F.Log;
import static org.matheclipse.core.expression.F.Noo;
import static org.matheclipse.core.expression.F.Pi;
import static org.matheclipse.core.expression.F.Plus;
import static org.matheclipse.core.expression.F.Power;
import static org.matheclipse.core.expression.F.RealNumberQ;
import static org.matheclipse.core.expression.F.Times;
import static org.matheclipse.core.expression.F.a;
import static org.matheclipse.core.expression.F.a_;
import static org.matheclipse.core.expression.F.b;
import static org.matheclipse.core.expression.F.b_;
import static org.matheclipse.core.expression.F.m;
import static org.matheclipse.core.expression.F.num;
import static org.matheclipse.core.expression.F.oo;
import static org.matheclipse.core.expression.F.x;
import static org.matheclipse.core.expression.F.z;
import static org.matheclipse.core.expression.F.z_;

/**
 * <p>Generated by <code>org.matheclipse.core.preprocessor.RulePreprocessor</code>.</p>
 * <p>See GIT repository at: <a href="https://bitbucket.org/axelclk/symja_android_library">bitbucket.org/axelclk/symja_android_library under the tools directory</a>.</p>
 */
public interface LogRules {
    /**
     * <ul>
     * <li>index 0 - number of equal rules in <code>RULES</code></li>
     * </ul>
     */
    final public static int[] SIZES = {19, 3};

    final public static IAST RULES = List(
            IInit(Log, SIZES),
            // Log(1)=0
            ISet(Log(C1),
                    C0),
            // Log(E)=1
            ISet(Log(E),
                    C1),
            // Log(E^x_RealNumberQ):=x
            ISetDelayed(Log(Power(E, $p(x, RealNumberQ))),
                    x),
            // Log(E^I)=I
            ISet(Log(Power(E, CI)),
                    CI),
            // Log(1/E^I)=-I
            ISet(Log(Power(E, CNI)),
                    CNI),
            // Log(0.0)=Indeterminate
            ISet(Log(num(0.0)),
                    Indeterminate),
            // Log(0)=-Infinity
            ISet(Log(C0),
                    Noo),
            // Log(I)=1/2*I*Pi
            ISet(Log(CI),
                    Times(CC(0L, 1L, 1L, 2L), Pi)),
            // Log(-I)=1/2*I*-Pi
            ISet(Log(CNI),
                    Times(CC(0L, 1L, -1L, 2L), Pi)),
            // Log(GoldenRatio)=ArcCsch(2)
            ISet(Log(GoldenRatio),
                    ArcCsch(C2)),
            // Log(1/2*(1+Sqrt(5)))=ArcCsch(2)
            ISet(Log(Times(C1D2, Plus(C1, CSqrt5))),
                    ArcCsch(C2)),
            // Log(Infinity)=Infinity
            ISet(Log(oo),
                    oo),
            // Log(-Infinity)=Infinity
            ISet(Log(Noo),
                    oo),
            // Log(I*Infinity)=Infinity
            ISet(Log(DirectedInfinity(CI)),
                    oo),
            // Log(-I*Infinity)=Infinity
            ISet(Log(DirectedInfinity(CNI)),
                    oo),
            // Log(ComplexInfinity)=Infinity
            ISet(Log(CComplexInfinity),
                    oo),
            // Log(a_,b_):=Log(b)/Log(a)
            ISetDelayed(Log(a_, b_),
                    Times(Log(b), Power(Log(a), -1))),
            // Log(a_,E):=1/Log(a)
            ISetDelayed(Log(a_, E),
                    Power(Log(a), -1)),
            // Log(a_,E^m_IntegerQ):=m/Log(a)
            ISetDelayed(Log(a_, Power(E, $p(m, IntegerQ))),
                    Times(m, Power(Log(a), -1))),
            // Log(a_,0):=-Infinity/Log(a)
            ISetDelayed(Log(a_, C0),
                    Times(CN1, oo, Power(Log(a), -1))),
            // Log(a_,1)=0
            ISet(Log(a_, C1),
                    C0),
            // Log(a_,-1):=(I*Pi)/Log(a)
            ISetDelayed(Log(a_, CN1),
                    Times(CI, Pi, Power(Log(a), -1))),
            // Log(E,z_):=Log(z)
            ISetDelayed(Log(E, z_),
                    Log(z)),
            // Log(0,z_)=0
            ISet(Log(C0, z_),
                    C0),
            // Log(1,z_)=ComplexInfinity
            ISet(Log(C1, z_),
                    CComplexInfinity),
            // Log(-1,z_):=-I/Pi*Log(z)
            ISetDelayed(Log(CN1, z_),
                    Times(CNI, Power(Pi, -1), Log(z))),
            // Log(a_,1)=Indeterminate
            ISet(Log(a_, C1),
                    Indeterminate)
    );
}
