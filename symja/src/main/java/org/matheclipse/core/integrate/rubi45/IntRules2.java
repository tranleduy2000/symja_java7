package org.matheclipse.core.integrate.rubi45;


import org.matheclipse.core.interfaces.IAST;

import static org.matheclipse.core.expression.F.And;
import static org.matheclipse.core.expression.F.AppellF1;
import static org.matheclipse.core.expression.F.ArcSin;
import static org.matheclipse.core.expression.F.ArcTan;
import static org.matheclipse.core.expression.F.C0;
import static org.matheclipse.core.expression.F.C1;
import static org.matheclipse.core.expression.F.C1D3;
import static org.matheclipse.core.expression.F.C1DSqrt3;
import static org.matheclipse.core.expression.F.C2;
import static org.matheclipse.core.expression.F.C3;
import static org.matheclipse.core.expression.F.C4;
import static org.matheclipse.core.expression.F.C5;
import static org.matheclipse.core.expression.F.C9;
import static org.matheclipse.core.expression.F.CN1;
import static org.matheclipse.core.expression.F.CN1D2;
import static org.matheclipse.core.expression.F.CN2;
import static org.matheclipse.core.expression.F.CSqrt3;
import static org.matheclipse.core.expression.F.Coefficient;
import static org.matheclipse.core.expression.F.Condition;
import static org.matheclipse.core.expression.F.Denominator;
import static org.matheclipse.core.expression.F.EllipticE;
import static org.matheclipse.core.expression.F.EllipticF;
import static org.matheclipse.core.expression.F.Equal;
import static org.matheclipse.core.expression.F.FractionalPart;
import static org.matheclipse.core.expression.F.FreeQ;
import static org.matheclipse.core.expression.F.Greater;
import static org.matheclipse.core.expression.F.GreaterEqual;
import static org.matheclipse.core.expression.F.Hypergeometric2F1;
import static org.matheclipse.core.expression.F.ISetDelayed;
import static org.matheclipse.core.expression.F.IntegerPart;
import static org.matheclipse.core.expression.F.IntegerQ;
import static org.matheclipse.core.expression.F.LeafCount;
import static org.matheclipse.core.expression.F.Less;
import static org.matheclipse.core.expression.F.LessEqual;
import static org.matheclipse.core.expression.F.List;
import static org.matheclipse.core.expression.F.Log;
import static org.matheclipse.core.expression.F.Module;
import static org.matheclipse.core.expression.F.Negate;
import static org.matheclipse.core.expression.F.Not;
import static org.matheclipse.core.expression.F.Or;
import static org.matheclipse.core.expression.F.Plus;
import static org.matheclipse.core.expression.F.Power;
import static org.matheclipse.core.expression.F.QQ;
import static org.matheclipse.core.expression.F.Set;
import static org.matheclipse.core.expression.F.Simplify;
import static org.matheclipse.core.expression.F.Sqr;
import static org.matheclipse.core.expression.F.Sqrt;
import static org.matheclipse.core.expression.F.Times;
import static org.matheclipse.core.expression.F.a;
import static org.matheclipse.core.expression.F.a_;
import static org.matheclipse.core.expression.F.a_DEFAULT;
import static org.matheclipse.core.expression.F.b;
import static org.matheclipse.core.expression.F.b_DEFAULT;
import static org.matheclipse.core.expression.F.c;
import static org.matheclipse.core.expression.F.c_;
import static org.matheclipse.core.expression.F.c_DEFAULT;
import static org.matheclipse.core.expression.F.d;
import static org.matheclipse.core.expression.F.d_DEFAULT;
import static org.matheclipse.core.expression.F.e;
import static org.matheclipse.core.expression.F.e_;
import static org.matheclipse.core.expression.F.e_DEFAULT;
import static org.matheclipse.core.expression.F.f;
import static org.matheclipse.core.expression.F.f_DEFAULT;
import static org.matheclipse.core.expression.F.m;
import static org.matheclipse.core.expression.F.m_;
import static org.matheclipse.core.expression.F.m_DEFAULT;
import static org.matheclipse.core.expression.F.n;
import static org.matheclipse.core.expression.F.n_;
import static org.matheclipse.core.expression.F.n_DEFAULT;
import static org.matheclipse.core.expression.F.p;
import static org.matheclipse.core.expression.F.p_;
import static org.matheclipse.core.expression.F.p_DEFAULT;
import static org.matheclipse.core.expression.F.q;
import static org.matheclipse.core.expression.F.u;
import static org.matheclipse.core.expression.F.u_;
import static org.matheclipse.core.expression.F.v;
import static org.matheclipse.core.expression.F.v_;
import static org.matheclipse.core.expression.F.w;
import static org.matheclipse.core.expression.F.w_;
import static org.matheclipse.core.expression.F.x;
import static org.matheclipse.core.expression.F.x_;
import static org.matheclipse.core.expression.F.x_Symbol;
import static org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors.ExpandIntegrand;
import static org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors.ExpandToSum;
import static org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors.FractionQ;
import static org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors.Int;
import static org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors.IntegersQ;
import static org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors.LinearMatchQ;
import static org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors.LinearQ;
import static org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors.NegQ;
import static org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors.NegativeIntegerQ;
import static org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors.NegativeQ;
import static org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors.NonzeroQ;
import static org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors.PosQ;
import static org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors.PositiveIntegerQ;
import static org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors.PositiveQ;
import static org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors.RationalQ;
import static org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors.Rt;
import static org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors.Simp;
import static org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors.Subst;
import static org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors.SumSimplerQ;
import static org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors.ZeroQ;

/**
 * IndefiniteIntegrationRules from the <a href="http://www.apmaths.uwo.ca/~arich/">Rubi -
 * rule-based integrator</a>.
 */
public class IntRules2 {
    public static IAST RULES = List(
            ISetDelayed(Int(Times(Power(Plus(a_, Times(b_DEFAULT, x_)), m_DEFAULT), Power(Plus(c_, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_DEFAULT)), x_Symbol),
                    Condition(Int(Times(Power(Plus(Times(a, c), Times(b, d, Sqr(x))), m), Power(Plus(e, Times(f, x)), p)), x), And(And(And(FreeQ(List(a, b, c, d, e, f, m, n, p), x), ZeroQ(Plus(m, Negate(n)))), ZeroQ(Plus(Times(b, c), Times(a, d)))), IntegerQ(m)))),
            ISetDelayed(Int(Times(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_DEFAULT)), x_Symbol),
                    Condition(Times(b, Power(Plus(c, Times(d, x)), Plus(n, C1)), Power(Plus(e, Times(f, x)), Plus(p, C1)), Power(Times(d, f, Plus(n, p, C2)), -1)), And(And(And(And(And(FreeQ(List(a, b, c, d, e, f, n, p), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), ZeroQ(Plus(Times(a, d, f, Plus(n, p, C2)), Times(CN1, b, Plus(Times(d, e, Plus(n, C1)), Times(c, f, Plus(p, C1))))))), NonzeroQ(Plus(n, p, C2))))),
            ISetDelayed(Int(Times(Plus(a_, Times(b_DEFAULT, x_)), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_DEFAULT), Power(Times(d_DEFAULT, x_), n_DEFAULT)), x_Symbol),
                    Condition(Int(ExpandIntegrand(Times(Plus(a, Times(b, x)), Power(Times(d, x), n), Power(Plus(e, Times(f, x)), p)), x), x), And(And(And(FreeQ(List(a, b, d, e, f, n), x), PositiveIntegerQ(p)), NonzeroQ(Plus(n, C1))), Or(Or(Or(Not(IntegerQ(n)), Less(Plus(Times(C9, p), Times(C5, n)), C0)), GreaterEqual(Plus(n, p, C1), C0)), And(GreaterEqual(Plus(n, p, C2), C0), RationalQ(a, b, d, e, f)))))),
            ISetDelayed(Int(Times(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), Power(Plus(c_, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_DEFAULT)), x_Symbol),
                    Condition(Int(ExpandIntegrand(Times(Plus(a, Times(b, x)), Power(Plus(c, Times(d, x)), n), Power(Plus(e, Times(f, x)), p)), x), x), And(And(FreeQ(List(a, b, c, d, e, f, n), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), Or(Or(NegativeIntegerQ(n, p), Equal(p, C1)), And(PositiveIntegerQ(p), Or(Or(Or(Not(IntegerQ(n)), LessEqual(Plus(Times(C9, p), Times(C5, Plus(n, C2))), C0)), GreaterEqual(Plus(n, p, C1), C0)), And(GreaterEqual(Plus(n, p, C2), C0), RationalQ(a, b, c, d, e, f)))))))),
            ISetDelayed(Int(Times(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_DEFAULT)), x_Symbol),
                    Condition(Plus(Times(Plus(Times(a, f), Times(CN1, b, e)), Power(Plus(c, Times(d, x)), Plus(n, C1)), Power(Plus(e, Times(f, x)), Plus(p, C1)), Power(Times(f, Plus(p, C1), Plus(Times(c, f), Times(CN1, d, e))), -1)), Times(CN1, Plus(Times(a, d, f, Plus(n, p, C2)), Times(CN1, b, Plus(Times(d, e, Plus(n, C1)), Times(c, f, Plus(p, C1))))), Power(Times(f, Plus(p, C1), Plus(Times(c, f), Times(CN1, d, e))), -1), Int(Times(Power(Plus(c, Times(d, x)), n), Power(Plus(e, Times(f, x)), Plus(p, C1))), x))), And(And(And(And(And(And(FreeQ(List(a, b, c, d, e, f, n), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), RationalQ(p)), Less(p, CN1)), Or(Or(Not(And(RationalQ(n), Less(n, CN1))), IntegerQ(p)), Not(Or(IntegerQ(n), Not(Or(ZeroQ(e), Not(Or(ZeroQ(c), Less(p, n))))))))))),
            ISetDelayed(Int(Times(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_DEFAULT)), x_Symbol),
                    Condition(Plus(Times(Plus(Times(a, f), Times(CN1, b, e)), Power(Plus(c, Times(d, x)), Plus(n, C1)), Power(Plus(e, Times(f, x)), Plus(p, C1)), Power(Times(f, Plus(p, C1), Plus(Times(c, f), Times(CN1, d, e))), -1)), Times(CN1, Plus(Times(a, d, f, Plus(n, p, C2)), Times(CN1, b, Plus(Times(d, e, Plus(n, C1)), Times(c, f, Plus(p, C1))))), Power(Times(f, Plus(p, C1), Plus(Times(c, f), Times(CN1, d, e))), -1), Int(Times(Power(Plus(c, Times(d, x)), n), Power(Plus(e, Times(f, x)), Simplify(Plus(p, C1)))), x))), And(And(And(And(And(FreeQ(List(a, b, c, d, e, f, n, p), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), Not(RationalQ(p))), SumSimplerQ(p, C1)))),
            ISetDelayed(Int(Times(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_DEFAULT)), x_Symbol),
                    Condition(Plus(Times(b, Power(Plus(c, Times(d, x)), Plus(n, C1)), Power(Plus(e, Times(f, x)), Plus(p, C1)), Power(Times(d, f, Plus(n, p, C2)), -1)), Times(Plus(Times(a, d, f, Plus(n, p, C2)), Times(CN1, b, Plus(Times(d, e, Plus(n, C1)), Times(c, f, Plus(p, C1))))), Power(Times(d, f, Plus(n, p, C2)), -1), Int(Times(Power(Plus(c, Times(d, x)), n), Power(Plus(e, Times(f, x)), p)), x))), And(And(And(And(FreeQ(List(a, b, c, d, e, f, n, p), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), NonzeroQ(Plus(n, p, C2))))),
            ISetDelayed(Int(Times(Power(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), -1), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_)), x_Symbol),
                    Condition(Int(ExpandIntegrand(Power(Plus(e, Times(f, x)), FractionalPart(p)), Times(Power(Plus(c, Times(d, x)), n), Power(Plus(e, Times(f, x)), IntegerPart(p)), Power(Plus(a, Times(b, x)), -1)), x), x), And(And(And(And(And(And(FreeQ(List(a, b, c, d, e, f), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), PositiveIntegerQ(n)), FractionQ(p)), Less(p, CN1)))),
            ISetDelayed(Int(Times(Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_DEFAULT), Power(Times(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), Plus(c_DEFAULT, Times(d_DEFAULT, x_))), -1)), x_Symbol),
                    Condition(Int(ExpandIntegrand(Times(Power(Plus(e, Times(f, x)), p), Power(Times(Plus(a, Times(b, x)), Plus(c, Times(d, x))), -1)), x), x), And(And(And(And(FreeQ(List(a, b, c, d, e, f), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), IntegerQ(p)))),
            ISetDelayed(Int(Times(Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_DEFAULT), Power(Times(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), Plus(c_DEFAULT, Times(d_DEFAULT, x_))), -1)), x_Symbol),
                    Condition(Plus(Times(Plus(Times(b, e), Times(CN1, a, f)), Power(Plus(Times(b, c), Times(CN1, a, d)), -1), Int(Times(Power(Plus(e, Times(f, x)), Plus(p, Negate(C1))), Power(Plus(a, Times(b, x)), -1)), x)), Times(CN1, Plus(Times(d, e), Times(CN1, c, f)), Power(Plus(Times(b, c), Times(CN1, a, d)), -1), Int(Times(Power(Plus(e, Times(f, x)), Plus(p, Negate(C1))), Power(Plus(c, Times(d, x)), -1)), x))), And(And(And(And(And(FreeQ(List(a, b, c, d, e, f), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), RationalQ(p)), Less(Less(C0, p), C1)))),
            ISetDelayed(Int(Times(Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_), Power(Times(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), Plus(c_DEFAULT, Times(d_DEFAULT, x_))), -1)), x_Symbol),
                    Condition(Plus(Times(f, Power(Plus(e, Times(f, x)), Plus(p, Negate(C1))), Power(Times(b, d, Plus(p, Negate(C1))), -1)), Times(Power(Times(b, d), -1), Int(Times(Plus(Times(b, d, Sqr(e)), Times(CN1, a, c, Sqr(f)), Times(f, Plus(Times(C2, b, d, e), Times(CN1, b, c, f), Times(CN1, a, d, f)), x)), Power(Plus(e, Times(f, x)), Plus(p, Negate(C2))), Power(Times(Plus(a, Times(b, x)), Plus(c, Times(d, x))), -1)), x))), And(And(And(And(And(And(FreeQ(List(a, b, c, d, e, f), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), Not(IntegerQ(p))), RationalQ(p)), Greater(p, C1)))),
            ISetDelayed(Int(Times(Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_), Power(Times(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), Plus(c_DEFAULT, Times(d_DEFAULT, x_))), -1)), x_Symbol),
                    Condition(Plus(Times(f, Power(Plus(e, Times(f, x)), Plus(p, C1)), Power(Times(Plus(p, C1), Plus(Times(b, e), Times(CN1, a, f)), Plus(Times(d, e), Times(CN1, c, f))), -1)), Times(Power(Times(Plus(Times(b, e), Times(CN1, a, f)), Plus(Times(d, e), Times(CN1, c, f))), -1), Int(Times(Plus(Times(b, d, e), Times(CN1, b, c, f), Times(CN1, a, d, f), Times(CN1, b, d, f, x)), Power(Plus(e, Times(f, x)), Plus(p, C1)), Power(Times(Plus(a, Times(b, x)), Plus(c, Times(d, x))), -1)), x))), And(And(And(And(And(And(FreeQ(List(a, b, c, d, e, f), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), Not(IntegerQ(p))), RationalQ(p)), Less(p, CN1)))),
            ISetDelayed(Int(Times(Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_), Power(Times(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), Plus(c_DEFAULT, Times(d_DEFAULT, x_))), -1)), x_Symbol),
                    Condition(Plus(Times(b, Power(Plus(Times(b, c), Times(CN1, a, d)), -1), Int(Times(Power(Plus(e, Times(f, x)), p), Power(Plus(a, Times(b, x)), -1)), x)), Times(CN1, d, Power(Plus(Times(b, c), Times(CN1, a, d)), -1), Int(Times(Power(Plus(e, Times(f, x)), p), Power(Plus(c, Times(d, x)), -1)), x))), And(And(And(And(FreeQ(List(a, b, c, d, e, f, p), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), Not(And(RationalQ(p), Or(Greater(p, C0), LessEqual(p, CN1))))))),
            ISetDelayed(Int(Times(Sqrt(Plus(e_DEFAULT, Times(f_DEFAULT, x_))), Power(Times(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), Sqrt(Plus(c_DEFAULT, Times(d_DEFAULT, x_)))), -1)), x_Symbol),
                    Condition(Plus(Times(f, Power(b, -1), Int(Power(Times(Sqrt(Plus(c, Times(d, x))), Sqrt(Plus(e, Times(f, x)))), -1), x)), Times(Plus(Times(b, e), Times(CN1, a, f)), Power(b, -1), Int(Power(Times(Plus(a, Times(b, x)), Sqrt(Plus(c, Times(d, x))), Sqrt(Plus(e, Times(f, x)))), -1), x))), And(And(FreeQ(List(a, b, c, d, e, f), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))))),
            ISetDelayed(Int(Power(Times(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), Sqrt(Plus(c_DEFAULT, Times(d_DEFAULT, x_))), Sqrt(Plus(e_DEFAULT, Times(f_DEFAULT, x_)))), -1), x_Symbol),
                    Condition(Times(CN2, Subst(Int(Power(Plus(Times(b, c), Times(CN1, a, d), Times(CN1, Plus(Times(b, e), Times(CN1, a, f)), Sqr(x))), -1), x), x, Times(Sqrt(Plus(c, Times(d, x))), Power(Plus(e, Times(f, x)), CN1D2)))), And(FreeQ(List(a, b, c, d, e, f), x), LessEqual(LeafCount(Simplify(Times(Plus(Times(b, e), Times(CN1, a, f)), Power(Plus(Times(a, d), Times(CN1, b, c)), -1)))), LeafCount(Simplify(Times(Plus(Times(b, c), Times(CN1, a, d)), Power(Plus(Times(a, f), Times(CN1, b, e)), -1)))))))),
            ISetDelayed(Int(Times(Sqrt(Plus(e_, Times(f_DEFAULT, x_))), Power(Times(Sqrt(Plus(c_, Times(d_DEFAULT, x_))), Sqrt(Times(b_DEFAULT, x_))), -1)), x_Symbol),
                    Condition(Times(C2, Sqrt(e), Power(b, -1), Rt(Times(CN1, b, Power(d, -1)), C2), EllipticE(ArcSin(Times(Sqrt(Times(b, x)), Power(Times(Sqrt(c), Rt(Times(CN1, b, Power(d, -1)), C2)), -1))), Times(c, f, Power(Times(d, e), -1)))), And(And(And(And(FreeQ(List(b, c, d, e, f), x), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), PositiveQ(c)), PositiveQ(e)), Not(NegativeQ(Times(CN1, b, Power(d, -1))))))),
            ISetDelayed(Int(Times(Sqrt(Plus(e_, Times(f_DEFAULT, x_))), Power(Times(Sqrt(Plus(c_, Times(d_DEFAULT, x_))), Sqrt(Times(b_DEFAULT, x_))), -1)), x_Symbol),
                    Condition(Times(Sqrt(Times(CN1, b, x)), Power(Times(b, x), CN1D2), Int(Times(Sqrt(Plus(e, Times(f, x))), Power(Times(Sqrt(Times(CN1, b, x)), Sqrt(Plus(c, Times(d, x)))), -1)), x)), And(And(And(And(FreeQ(List(b, c, d, e, f), x), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), PositiveQ(c)), PositiveQ(e)), NegativeQ(Times(CN1, b, Power(d, -1)))))),
            ISetDelayed(Int(Times(Sqrt(Plus(e_DEFAULT, Times(f_DEFAULT, x_))), Power(Times(Sqrt(Plus(a_DEFAULT, Times(b_DEFAULT, x_))), Sqrt(Plus(c_DEFAULT, Times(d_DEFAULT, x_)))), -1)), x_Symbol),
                    Condition(Times(C2, Power(b, -1), Rt(Times(CN1, Plus(Times(b, c), Times(CN1, a, d)), Power(d, -1)), C2), Sqrt(Times(Plus(Times(b, e), Times(CN1, a, f)), Power(Plus(Times(b, c), Times(CN1, a, d)), -1))), EllipticE(ArcSin(Times(Sqrt(Plus(a, Times(b, x))), Power(Rt(Times(CN1, Plus(Times(b, c), Times(CN1, a, d)), Power(d, -1)), C2), -1))), Times(f, Plus(Times(b, c), Times(CN1, a, d)), Power(Times(d, Plus(Times(b, e), Times(CN1, a, f))), -1)))), And(And(And(And(And(And(And(FreeQ(List(a, b, c, d, e, f), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), PositiveQ(Times(b, Power(Plus(Times(b, c), Times(CN1, a, d)), -1)))), PositiveQ(Times(b, Power(Plus(Times(b, e), Times(CN1, a, f)), -1)))), Not(NegativeQ(Times(CN1, Plus(Times(b, c), Times(CN1, a, d)), Power(d, -1))))), Not(NegativeQ(Times(f, Power(d, -1))))))),
            ISetDelayed(Int(Times(Sqrt(Plus(e_DEFAULT, Times(f_DEFAULT, x_))), Power(Times(Sqrt(Plus(a_DEFAULT, Times(b_DEFAULT, x_))), Sqrt(Plus(c_DEFAULT, Times(d_DEFAULT, x_)))), -1)), x_Symbol),
                    Condition(Times(Sqrt(Plus(Negate(a), Times(CN1, b, x))), Power(Plus(a, Times(b, x)), CN1D2), Int(Times(Sqrt(Plus(e, Times(f, x))), Power(Times(Sqrt(Plus(Negate(a), Times(CN1, b, x))), Sqrt(Plus(c, Times(d, x)))), -1)), x)), And(And(And(And(And(And(FreeQ(List(a, b, c, d, e, f), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), PositiveQ(Times(b, Power(Plus(Times(b, c), Times(CN1, a, d)), -1)))), PositiveQ(Times(b, Power(Plus(Times(b, e), Times(CN1, a, f)), -1)))), NegativeQ(Times(CN1, Plus(Times(b, c), Times(CN1, a, d)), Power(d, -1)))))),
            ISetDelayed(Int(Times(Sqrt(Plus(e_DEFAULT, Times(f_DEFAULT, x_))), Power(Times(Sqrt(Plus(a_DEFAULT, Times(b_DEFAULT, x_))), Sqrt(Plus(c_DEFAULT, Times(d_DEFAULT, x_)))), -1)), x_Symbol),
                    Condition(Times(Sqrt(Plus(e, Times(f, x))), Sqrt(Times(b, Plus(c, Times(d, x)), Power(Plus(Times(b, c), Times(CN1, a, d)), -1))), Power(Times(Sqrt(Plus(c, Times(d, x))), Sqrt(Times(b, Plus(e, Times(f, x)), Power(Plus(Times(b, e), Times(CN1, a, f)), -1)))), -1), Int(Times(Sqrt(Simp(Plus(Times(b, e, Power(Plus(Times(b, e), Times(CN1, a, f)), -1)), Times(b, f, x, Power(Plus(Times(b, e), Times(CN1, a, f)), -1))), x)), Power(Times(Sqrt(Plus(a, Times(b, x))), Sqrt(Simp(Plus(Times(b, c, Power(Plus(Times(b, c), Times(CN1, a, d)), -1)), Times(b, d, x, Power(Plus(Times(b, c), Times(CN1, a, d)), -1))), x))), -1)), x)), And(And(And(And(FreeQ(List(a, b, c, d, e, f), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), Not(And(PositiveQ(Times(b, Power(Plus(Times(b, c), Times(CN1, a, d)), -1))), PositiveQ(Times(b, Power(Plus(Times(b, e), Times(CN1, a, f)), -1)))))))),
            ISetDelayed(Int(Power(Times(Sqrt(Plus(c_, Times(d_DEFAULT, x_))), Sqrt(Plus(e_, Times(f_DEFAULT, x_))), Sqrt(Times(b_DEFAULT, x_))), -1), x_Symbol),
                    Condition(Times(C2, Power(Times(b, Sqrt(e)), -1), Rt(Times(CN1, b, Power(d, -1)), C2), EllipticF(ArcSin(Times(Sqrt(Times(b, x)), Power(Times(Sqrt(c), Rt(Times(CN1, b, Power(d, -1)), C2)), -1))), Times(c, f, Power(Times(d, e), -1)))), And(And(And(And(FreeQ(List(b, c, d, e, f), x), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), PositiveQ(c)), PositiveQ(e)), Not(NegativeQ(Times(CN1, b, Power(d, -1))))))),
            ISetDelayed(Int(Power(Times(Sqrt(Plus(c_, Times(d_DEFAULT, x_))), Sqrt(Plus(e_, Times(f_DEFAULT, x_))), Sqrt(Times(b_DEFAULT, x_))), -1), x_Symbol),
                    Condition(Times(Sqrt(Times(CN1, b, x)), Power(Times(b, x), CN1D2), Int(Power(Times(Sqrt(Times(CN1, b, x)), Sqrt(Plus(c, Times(d, x))), Sqrt(Plus(e, Times(f, x)))), -1), x)), And(And(And(And(FreeQ(List(b, c, d, e, f), x), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), PositiveQ(c)), PositiveQ(e)), NegativeQ(Times(CN1, b, Power(d, -1)))))),
            ISetDelayed(Int(Power(Times(Sqrt(Plus(a_DEFAULT, Times(b_DEFAULT, x_))), Sqrt(Plus(c_DEFAULT, Times(d_DEFAULT, x_))), Sqrt(Plus(e_DEFAULT, Times(f_DEFAULT, x_)))), -1), x_Symbol),
                    Condition(Times(C2, Power(b, -1), Rt(Times(CN1, Plus(Times(b, c), Times(CN1, a, d)), Power(d, -1)), C2), Sqrt(Times(Sqr(b), Power(Times(Plus(Times(b, c), Times(CN1, a, d)), Plus(Times(b, e), Times(CN1, a, f))), -1))), EllipticF(ArcSin(Times(Sqrt(Plus(a, Times(b, x))), Power(Rt(Times(CN1, Plus(Times(b, c), Times(CN1, a, d)), Power(d, -1)), C2), -1))), Times(f, Plus(Times(b, c), Times(CN1, a, d)), Power(Times(d, Plus(Times(b, e), Times(CN1, a, f))), -1)))), And(And(And(And(And(And(And(FreeQ(List(a, b, c, d, e, f), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), PositiveQ(Times(b, Power(Plus(Times(b, c), Times(CN1, a, d)), -1)))), PositiveQ(Times(b, Power(Plus(Times(b, e), Times(CN1, a, f)), -1)))), Not(NegativeQ(Times(CN1, Plus(Times(b, c), Times(CN1, a, d)), Power(d, -1))))), Not(NegativeQ(Times(f, Power(d, -1))))))),
            ISetDelayed(Int(Power(Times(Sqrt(Plus(a_DEFAULT, Times(b_DEFAULT, x_))), Sqrt(Plus(c_DEFAULT, Times(d_DEFAULT, x_))), Sqrt(Plus(e_DEFAULT, Times(f_DEFAULT, x_)))), -1), x_Symbol),
                    Condition(Times(Sqrt(Plus(Negate(a), Times(CN1, b, x))), Power(Plus(a, Times(b, x)), CN1D2), Int(Power(Times(Sqrt(Plus(Negate(a), Times(CN1, b, x))), Sqrt(Plus(c, Times(d, x))), Sqrt(Plus(e, Times(f, x)))), -1), x)), And(And(And(And(And(And(FreeQ(List(a, b, c, d, e, f), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), PositiveQ(Times(b, Power(Plus(Times(b, c), Times(CN1, a, d)), -1)))), PositiveQ(Times(b, Power(Plus(Times(b, e), Times(CN1, a, f)), -1)))), NegativeQ(Times(CN1, Plus(Times(b, c), Times(CN1, a, d)), Power(d, -1)))))),
            ISetDelayed(Int(Power(Times(Sqrt(Plus(a_DEFAULT, Times(b_DEFAULT, x_))), Sqrt(Plus(c_DEFAULT, Times(d_DEFAULT, x_))), Sqrt(Plus(e_DEFAULT, Times(f_DEFAULT, x_)))), -1), x_Symbol),
                    Condition(Times(Sqrt(Times(b, Plus(c, Times(d, x)), Power(Plus(Times(b, c), Times(CN1, a, d)), -1))), Sqrt(Times(b, Plus(e, Times(f, x)), Power(Plus(Times(b, e), Times(CN1, a, f)), -1))), Power(Times(Sqrt(Plus(c, Times(d, x))), Sqrt(Plus(e, Times(f, x)))), -1), Int(Power(Times(Sqrt(Plus(a, Times(b, x))), Sqrt(Simp(Plus(Times(b, c, Power(Plus(Times(b, c), Times(CN1, a, d)), -1)), Times(b, d, x, Power(Plus(Times(b, c), Times(CN1, a, d)), -1))), x)), Sqrt(Simp(Plus(Times(b, e, Power(Plus(Times(b, e), Times(CN1, a, f)), -1)), Times(b, f, x, Power(Plus(Times(b, e), Times(CN1, a, f)), -1))), x))), -1), x)), And(And(And(And(FreeQ(List(a, b, c, d, e, f), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), Not(And(PositiveQ(Times(b, Power(Plus(Times(b, c), Times(CN1, a, d)), -1))), PositiveQ(Times(b, Power(Plus(Times(b, e), Times(CN1, a, f)), -1)))))))),
            ISetDelayed(Int(Times(Power(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), m_DEFAULT), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_DEFAULT)), x_Symbol),
                    Condition(Int(ExpandIntegrand(Times(Power(Plus(a, Times(b, x)), m), Power(Plus(c, Times(d, x)), n), Power(Plus(e, Times(f, x)), p)), x), x), And(And(And(And(And(FreeQ(List(a, b, c, d, e, f, m), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), IntegersQ(m, n)), Or(Or(IntegerQ(p), And(Greater(m, C0), GreaterEqual(n, CN1))), And(And(Less(m, C0), Less(n, C0)), Not(RationalQ(p))))))),
            ISetDelayed(Int(Times(Sqr(Plus(a_DEFAULT, Times(b_DEFAULT, x_))), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_DEFAULT)), x_Symbol),
                    Condition(Plus(Times(Sqr(Plus(Times(b, c), Times(CN1, a, d))), Power(Plus(c, Times(d, x)), Plus(n, C1)), Power(Plus(e, Times(f, x)), Plus(p, C1)), Power(Times(Sqr(d), Plus(Times(d, e), Times(CN1, c, f)), Plus(n, C1)), -1)), Times(CN1, Power(Times(Sqr(d), Plus(Times(d, e), Times(CN1, c, f)), Plus(n, C1)), -1), Int(Times(Power(Plus(c, Times(d, x)), Plus(n, C1)), Power(Plus(e, Times(f, x)), p), Simp(Plus(Times(Sqr(a), Sqr(d), f, Plus(n, p, C2)), Times(Sqr(b), c, Plus(Times(d, e, Plus(n, C1)), Times(c, f, Plus(p, C1)))), Times(CN1, C2, a, b, d, Plus(Times(d, e, Plus(n, C1)), Times(c, f, Plus(p, C1)))), Times(CN1, Sqr(b), d, Plus(Times(d, e), Times(CN1, c, f)), Plus(n, C1), x)), x)), x))), And(And(And(And(FreeQ(List(a, b, c, d, e, f, n, p), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), Or(And(RationalQ(n), Less(n, CN1)), And(And(ZeroQ(Plus(n, p, C3)), NonzeroQ(Plus(n, C1))), Or(SumSimplerQ(n, C1), Not(SumSimplerQ(p, C1)))))))),
            ISetDelayed(Int(Times(Sqr(Plus(a_DEFAULT, Times(b_DEFAULT, x_))), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_DEFAULT)), x_Symbol),
                    Condition(Plus(Times(b, Plus(a, Times(b, x)), Power(Plus(c, Times(d, x)), Plus(n, C1)), Power(Plus(e, Times(f, x)), Plus(p, C1)), Power(Times(d, f, Plus(n, p, C3)), -1)), Times(Power(Times(d, f, Plus(n, p, C3)), -1), Int(Times(Power(Plus(c, Times(d, x)), n), Power(Plus(e, Times(f, x)), p), Simp(Plus(Times(Sqr(a), d, f, Plus(n, p, C3)), Times(CN1, b, Plus(Times(b, c, e), Times(a, Plus(Times(d, e, Plus(n, C1)), Times(c, f, Plus(p, C1)))))), Times(b, Plus(Times(a, d, f, Plus(n, p, C4)), Times(CN1, b, Plus(Times(d, e, Plus(n, C2)), Times(c, f, Plus(p, C2))))), x)), x)), x))), And(And(And(And(FreeQ(List(a, b, c, d, e, f, n, p), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), NonzeroQ(Plus(n, p, C3))))),
            ISetDelayed(Int(Times(Power(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), m_), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_DEFAULT)), x_Symbol),
                    Condition(Plus(Times(CN1, Power(Plus(a, Times(b, x)), Plus(m, C1)), Power(Plus(c, Times(d, x)), n), Power(Plus(e, Times(f, x)), Plus(p, C1)), Power(Times(Plus(m, C1), Plus(Times(a, f), Times(CN1, b, e))), -1)), Times(n, Plus(Times(d, e), Times(CN1, c, f)), Power(Times(Plus(m, C1), Plus(Times(a, f), Times(CN1, b, e))), -1), Int(Times(Power(Plus(a, Times(b, x)), Plus(m, C1)), Power(Plus(c, Times(d, x)), Plus(n, Negate(C1))), Power(Plus(e, Times(f, x)), p)), x))), And(And(And(And(And(And(And(FreeQ(List(a, b, c, d, e, f, p), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), RationalQ(m, n)), Less(m, CN1)), Greater(n, C0)), ZeroQ(Plus(m, n, p, C2))))),
            ISetDelayed(Int(Times(Power(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), m_), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_DEFAULT)), x_Symbol),
                    Condition(Plus(Times(Power(Plus(a, Times(b, x)), Plus(m, C1)), Power(Plus(c, Times(d, x)), n), Power(Plus(e, Times(f, x)), p), Power(Times(b, Plus(m, C1)), -1)), Times(CN1, Power(Times(b, Plus(m, C1)), -1), Int(Times(Power(Plus(a, Times(b, x)), Plus(m, C1)), Power(Plus(c, Times(d, x)), Plus(n, Negate(C1))), Power(Plus(e, Times(f, x)), Plus(p, Negate(C1))), Simp(Plus(Times(d, e, n), Times(c, f, p), Times(d, f, Plus(n, p), x)), x)), x))), And(And(And(And(And(And(And(And(FreeQ(List(a, b, c, d, e, f), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), RationalQ(m, n, p)), Less(m, CN1)), Greater(n, C0)), Greater(p, C0)), Or(Or(IntegersQ(Times(C2, m), Times(C2, n), Times(C2, p)), IntegersQ(m, Plus(n, p))), IntegersQ(p, Plus(m, n)))))),
            ISetDelayed(Int(Times(Power(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), m_DEFAULT), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_DEFAULT)), x_Symbol),
                    Condition(Plus(Times(Power(Plus(a, Times(b, x)), m), Power(Plus(c, Times(d, x)), n), Power(Plus(e, Times(f, x)), Plus(p, C1)), Power(Times(f, Plus(m, n, p, C1)), -1)), Times(Power(Times(f, Plus(m, n, p, C1)), -1), Int(Times(Power(Plus(a, Times(b, x)), Plus(m, Negate(C1))), Power(Plus(c, Times(d, x)), Plus(n, Negate(C1))), Power(Plus(e, Times(f, x)), p), Simp(Plus(Times(c, m, Plus(Times(a, f), Times(CN1, b, e))), Times(a, n, Plus(Times(c, f), Times(CN1, d, e))), Times(Plus(Times(d, m, Plus(Times(a, f), Times(CN1, b, e))), Times(b, n, Plus(Times(c, f), Times(CN1, d, e)))), x)), x)), x))), And(And(And(And(And(And(And(And(FreeQ(List(a, b, c, d, e, f), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), RationalQ(m, n, p)), Greater(m, C0)), Greater(n, C0)), NonzeroQ(Plus(m, n, p, C1))), Or(IntegersQ(Times(C2, m), Times(C2, n), Times(C2, p)), IntegersQ(p, Plus(m, n)))))),
            ISetDelayed(Int(Times(Power(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), m_), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_DEFAULT)), x_Symbol),
                    Condition(Plus(Times(CN1, Power(Plus(a, Times(b, x)), Plus(m, C1)), Power(Plus(c, Times(d, x)), n), Power(Plus(e, Times(f, x)), Plus(p, C1)), Power(Times(Plus(m, C1), Plus(Times(a, f), Times(CN1, b, e))), -1)), Times(Power(Times(Plus(m, C1), Plus(Times(a, f), Times(CN1, b, e))), -1), Int(Times(Power(Plus(a, Times(b, x)), Plus(m, C1)), Power(Plus(c, Times(d, x)), Plus(n, Negate(C1))), Power(Plus(e, Times(f, x)), p), Simp(Plus(Times(d, e, n), Times(c, f, Plus(m, p, C2)), Times(d, f, Plus(m, n, p, C2), x)), x)), x))), And(And(And(And(And(And(And(And(FreeQ(List(a, b, c, d, e, f), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), RationalQ(m, n, p)), Less(m, CN1)), Greater(n, C0)), Not(And(And(IntegerQ(n), Greater(n, C1)), Greater(Plus(m, n, p, C1), C0)))), Or(Or(IntegersQ(Times(C2, m), Times(C2, n), Times(C2, p)), IntegersQ(p, Plus(m, n))), IntegersQ(m, Plus(n, p)))))),
            ISetDelayed(Int(Times(Power(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), m_), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_DEFAULT)), x_Symbol),
                    Condition(Plus(Times(b, Power(Plus(a, Times(b, x)), Plus(m, Negate(C1))), Power(Plus(c, Times(d, x)), Plus(n, C1)), Power(Plus(e, Times(f, x)), Plus(p, C1)), Power(Times(d, f, Plus(m, n, p, C1)), -1)), Times(Power(Times(d, f, Plus(m, n, p, C1)), -1), Int(Times(Power(Plus(a, Times(b, x)), Plus(m, Negate(C2))), Power(Plus(c, Times(d, x)), n), Power(Plus(e, Times(f, x)), p), Simp(Plus(Times(Sqr(a), d, f, Plus(m, n, p, C1)), Times(CN1, b, Plus(Times(b, c, e, Plus(m, Negate(C1))), Times(a, Plus(Times(d, e, Plus(n, C1)), Times(c, f, Plus(p, C1)))))), Times(b, Plus(Times(a, d, f, Plus(Times(C2, m), n, p)), Times(CN1, b, Plus(Times(d, e, Plus(m, n)), Times(c, f, Plus(m, p))))), x)), x)), x))), And(And(And(And(And(And(And(FreeQ(List(a, b, c, d, e, f, n, p), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), RationalQ(m)), Greater(m, C1)), NonzeroQ(Plus(m, n, p, C1))), Or(Or(IntegerQ(m), IntegersQ(Times(C2, m), Times(C2, n), Times(C2, p))), NegativeIntegerQ(Plus(m, n, p, C1)))))),
            ISetDelayed(Int(Times(Power(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), m_), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_DEFAULT)), x_Symbol),
                    Condition(Plus(Times(b, Power(Plus(a, Times(b, x)), Plus(m, C1)), Power(Plus(c, Times(d, x)), Plus(n, C1)), Power(Plus(e, Times(f, x)), Plus(p, C1)), Power(Times(Plus(m, C1), Plus(Times(b, c), Times(CN1, a, d)), Plus(Times(b, e), Times(CN1, a, f))), -1)), Times(Power(Times(Plus(m, C1), Plus(Times(b, c), Times(CN1, a, d)), Plus(Times(b, e), Times(CN1, a, f))), -1), Int(Times(Power(Plus(a, Times(b, x)), Plus(m, C1)), Power(Plus(c, Times(d, x)), n), Power(Plus(e, Times(f, x)), p), Simp(Plus(Times(a, d, f, Plus(m, C1)), Times(CN1, b, Plus(Times(d, e, Plus(m, n, C2)), Times(c, f, Plus(m, p, C2)))), Times(CN1, b, d, f, Plus(m, n, p, C3), x)), x)), x))), And(And(And(And(And(And(FreeQ(List(a, b, c, d, e, f, n, p), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), RationalQ(m, n, p)), Less(m, CN1)), Or(IntegersQ(Times(C2, m), Times(C2, n), Times(C2, p)), IntegersQ(m, Plus(n, p)))))),
            ISetDelayed(Int(Times(Power(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), m_), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_DEFAULT)), x_Symbol),
                    Condition(Module(List(Set(q, Denominator(m))), Times(q, Plus(Times(b, c), Times(CN1, a, d)), Subst(Int(Times(Power(x, Plus(Times(q, Plus(m, C1)), Negate(C1))), Power(Plus(Times(b, e), Times(CN1, a, f), Times(CN1, Plus(Times(d, e), Times(CN1, c, f)), Power(x, q))), p), Power(Power(Plus(b, Times(CN1, d, Power(x, q))), Plus(p, C2)), -1)), x), x, Times(Power(Plus(a, Times(b, x)), Power(q, -1)), Power(Power(Plus(c, Times(d, x)), Power(q, -1)), -1))))), And(And(And(And(And(And(And(FreeQ(List(a, b, c, d, e, f), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), RationalQ(m, n)), Less(Less(C0, m), C1)), Equal(Plus(m, n), C0)), IntegerQ(p)))),
            ISetDelayed(Int(Power(Times(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), C1D3), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), QQ(2L, 3L))), -1), x_Symbol),
                    Condition(Plus(Times(CN1, Log(Plus(a, Times(b, x))), Power(Times(C2, Rt(Plus(Times(b, c), Times(CN1, a, d)), C3), Sqr(Rt(Plus(Times(b, e), Times(CN1, a, f)), C3))), -1)), Times(CSqrt3, Power(Times(Rt(Plus(Times(b, c), Times(CN1, a, d)), C3), Sqr(Rt(Plus(Times(b, e), Times(CN1, a, f)), C3))), -1), ArcTan(Times(C1DSqrt3, Plus(C1, Times(C2, Rt(Plus(Times(b, e), Times(CN1, a, f)), C3), Power(Plus(c, Times(d, x)), C1D3), Power(Times(Rt(Plus(Times(b, c), Times(CN1, a, d)), C3), Power(Plus(e, Times(f, x)), C1D3)), -1)))))), Times(C3, Power(Times(C2, Rt(Plus(Times(b, c), Times(CN1, a, d)), C3), Sqr(Rt(Plus(Times(b, e), Times(CN1, a, f)), C3))), -1), Log(Plus(Times(Rt(Plus(Times(b, e), Times(CN1, a, f)), C3), Power(Plus(c, Times(d, x)), C1D3)), Times(CN1, Rt(Plus(Times(b, c), Times(CN1, a, d)), C3), Power(Plus(e, Times(f, x)), C1D3)))))), And(And(And(And(And(FreeQ(List(a, b, c, d, e, f), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), PosQ(Plus(Times(b, c), Times(CN1, a, d)))), PosQ(Plus(Times(b, e), Times(CN1, a, f)))))),
            ISetDelayed(Int(Power(Times(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), C1D3), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), QQ(2L, 3L))), -1), x_Symbol),
                    Condition(Plus(Times(CN1, Log(Plus(a, Times(b, x))), Power(Times(C2, Rt(Plus(Times(b, c), Times(CN1, a, d)), C3), Sqr(Rt(Negate(Plus(Times(b, e), Times(CN1, a, f))), C3))), -1)), Times(CSqrt3, Power(Times(Rt(Plus(Times(b, c), Times(CN1, a, d)), C3), Sqr(Rt(Negate(Plus(Times(b, e), Times(CN1, a, f))), C3))), -1), ArcTan(Times(C1DSqrt3, Plus(C1, Times(CN1, C2, Rt(Negate(Plus(Times(b, e), Times(CN1, a, f))), C3), Power(Plus(c, Times(d, x)), C1D3), Power(Times(Rt(Plus(Times(b, c), Times(CN1, a, d)), C3), Power(Plus(e, Times(f, x)), C1D3)), -1)))))), Times(C3, Power(Times(C2, Rt(Plus(Times(b, c), Times(CN1, a, d)), C3), Sqr(Rt(Negate(Plus(Times(b, e), Times(CN1, a, f))), C3))), -1), Log(Plus(Times(Rt(Negate(Plus(Times(b, e), Times(CN1, a, f))), C3), Power(Plus(c, Times(d, x)), C1D3)), Times(Rt(Plus(Times(b, c), Times(CN1, a, d)), C3), Power(Plus(e, Times(f, x)), C1D3)))))), And(And(And(And(And(FreeQ(List(a, b, c, d, e, f), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), PosQ(Plus(Times(b, c), Times(CN1, a, d)))), NegQ(Plus(Times(b, e), Times(CN1, a, f)))))),
            ISetDelayed(Int(Power(Times(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), C1D3), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), QQ(2L, 3L))), -1), x_Symbol),
                    Condition(Plus(Times(Log(Plus(a, Times(b, x))), Power(Times(C2, Rt(Negate(Plus(Times(b, c), Times(CN1, a, d))), C3), Sqr(Rt(Plus(Times(b, e), Times(CN1, a, f)), C3))), -1)), Times(CN1, CSqrt3, Power(Times(Rt(Negate(Plus(Times(b, c), Times(CN1, a, d))), C3), Sqr(Rt(Plus(Times(b, e), Times(CN1, a, f)), C3))), -1), ArcTan(Times(C1DSqrt3, Plus(C1, Times(CN1, C2, Rt(Plus(Times(b, e), Times(CN1, a, f)), C3), Power(Plus(c, Times(d, x)), C1D3), Power(Times(Rt(Negate(Plus(Times(b, c), Times(CN1, a, d))), C3), Power(Plus(e, Times(f, x)), C1D3)), -1)))))), Times(CN1, C3, Power(Times(C2, Rt(Negate(Plus(Times(b, c), Times(CN1, a, d))), C3), Sqr(Rt(Plus(Times(b, e), Times(CN1, a, f)), C3))), -1), Log(Plus(Times(Rt(Plus(Times(b, e), Times(CN1, a, f)), C3), Power(Plus(c, Times(d, x)), C1D3)), Times(Rt(Negate(Plus(Times(b, c), Times(CN1, a, d))), C3), Power(Plus(e, Times(f, x)), C1D3)))))), And(And(And(And(And(FreeQ(List(a, b, c, d, e, f), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), NegQ(Plus(Times(b, c), Times(CN1, a, d)))), PosQ(Plus(Times(b, e), Times(CN1, a, f)))))),
            ISetDelayed(Int(Power(Times(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), C1D3), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), QQ(2L, 3L))), -1), x_Symbol),
                    Condition(Plus(Times(Log(Plus(a, Times(b, x))), Power(Times(C2, Rt(Negate(Plus(Times(b, c), Times(CN1, a, d))), C3), Sqr(Rt(Negate(Plus(Times(b, e), Times(CN1, a, f))), C3))), -1)), Times(CN1, CSqrt3, Power(Times(Rt(Negate(Plus(Times(b, c), Times(CN1, a, d))), C3), Sqr(Rt(Negate(Plus(Times(b, e), Times(CN1, a, f))), C3))), -1), ArcTan(Times(C1DSqrt3, Plus(C1, Times(C2, Rt(Negate(Plus(Times(b, e), Times(CN1, a, f))), C3), Power(Plus(c, Times(d, x)), C1D3), Power(Times(Power(Negate(Plus(Times(b, c), Times(CN1, a, d))), C1D3), Power(Plus(e, Times(f, x)), C1D3)), -1)))))), Times(CN1, C3, Power(Times(C2, Rt(Negate(Plus(Times(b, c), Times(CN1, a, d))), C3), Sqr(Rt(Negate(Plus(Times(b, e), Times(CN1, a, f))), C3))), -1), Log(Plus(Times(Rt(Negate(Plus(Times(b, e), Times(CN1, a, f))), C3), Power(Plus(c, Times(d, x)), C1D3)), Times(CN1, Power(Negate(Plus(Times(b, c), Times(CN1, a, d))), C1D3), Power(Plus(e, Times(f, x)), C1D3)))))), And(And(And(And(And(FreeQ(List(a, b, c, d, e, f), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), NegQ(Plus(Times(b, c), Times(CN1, a, d)))), NegQ(Plus(Times(b, e), Times(CN1, a, f)))))),
            ISetDelayed(Int(Times(Power(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), m_), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_DEFAULT)), x_Symbol),
                    Condition(Module(List(Set(q, Denominator(m))), Times(q, Subst(Int(Times(Power(x, Plus(Times(q, Plus(m, C1)), Negate(C1))), Power(Plus(Times(b, e), Times(CN1, a, f), Times(CN1, Plus(Times(d, e), Times(CN1, c, f)), Power(x, q))), p), Power(Power(Plus(b, Times(CN1, d, Power(x, q))), Plus(p, C1)), -1)), x), x, Times(Power(Plus(a, Times(b, x)), Power(q, -1)), Power(Power(Plus(c, Times(d, x)), Power(q, -1)), -1))))), And(And(And(And(And(And(And(FreeQ(List(a, b, c, d, e, f), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), RationalQ(m, n)), Less(Less(CN1, m), C0)), Equal(Plus(m, n, C1), C0)), IntegerQ(p)))),
            ISetDelayed(Int(Times(Power(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), m_DEFAULT), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Times(f_DEFAULT, x_), p_DEFAULT)), x_Symbol),
                    Condition(Int(Times(Power(Plus(Times(a, c), Times(b, d, Sqr(x))), m), Power(Times(f, x), p)), x), And(And(And(And(FreeQ(List(a, b, c, d, f, m, n, p), x), ZeroQ(Plus(Times(b, c), Times(a, d)))), ZeroQ(Plus(m, Negate(n)))), PositiveQ(a)), PositiveQ(c)))),
            ISetDelayed(Int(Times(Power(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), m_DEFAULT), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Times(f_DEFAULT, x_), p_DEFAULT)), x_Symbol),
                    Condition(Times(Power(Plus(a, Times(b, x)), m), Power(Plus(c, Times(d, x)), m), Power(Power(Plus(Times(a, c), Times(b, d, Sqr(x))), m), -1), Int(Times(Power(Plus(Times(a, c), Times(b, d, Sqr(x))), m), Power(Times(f, x), p)), x)), And(And(FreeQ(List(a, b, c, d, f, m, n, p), x), ZeroQ(Plus(Times(b, c), Times(a, d)))), ZeroQ(Plus(m, Negate(n)))))),
            ISetDelayed(Int(Times(Power(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), m_DEFAULT), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Times(f_DEFAULT, x_), p_DEFAULT)), x_Symbol),
                    Condition(Int(ExpandIntegrand(Times(Power(Plus(a, Times(b, x)), n), Power(Plus(c, Times(d, x)), n), Power(Times(f, x), p)), Power(Plus(a, Times(b, x)), Plus(m, Negate(n))), x), x), And(And(FreeQ(List(a, b, c, d, f, m, n, p), x), ZeroQ(Plus(Times(b, c), Times(a, d)))), PositiveIntegerQ(Plus(m, Negate(n)))))),
            ISetDelayed(Int(Times(Power(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), m_), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_)), x_Symbol),
                    Condition(Times(Power(Plus(Times(b, c), Times(CN1, a, d)), n), Power(Plus(a, Times(b, x)), Plus(m, C1)), Power(Times(Plus(m, C1), Power(Plus(Times(b, e), Times(CN1, a, f)), Plus(n, C1)), Power(Plus(e, Times(f, x)), Plus(m, C1))), -1), Hypergeometric2F1(Plus(m, C1), Negate(n), Plus(m, C2), Times(CN1, Plus(Times(d, e), Times(CN1, c, f)), Plus(a, Times(b, x)), Power(Times(Plus(Times(b, c), Times(CN1, a, d)), Plus(e, Times(f, x))), -1)))), And(And(And(And(And(FreeQ(List(a, b, c, d, e, f, m, p), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), ZeroQ(Plus(m, n, p, C2))), IntegerQ(n)))),
            ISetDelayed(Int(Times(Power(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), m_), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_)), x_Symbol),
                    Condition(Times(Power(Plus(a, Times(b, x)), Plus(m, C1)), Power(Plus(c, Times(d, x)), n), Power(Plus(e, Times(f, x)), Plus(p, C1)), Power(Times(Plus(Times(b, e), Times(CN1, a, f)), Plus(m, C1)), -1), Power(Times(Plus(Times(b, e), Times(CN1, a, f)), Plus(c, Times(d, x)), Power(Times(Plus(Times(b, c), Times(CN1, a, d)), Plus(e, Times(f, x))), -1)), Negate(n)), Hypergeometric2F1(Plus(m, C1), Negate(n), Plus(m, C2), Times(CN1, Plus(Times(d, e), Times(CN1, c, f)), Plus(a, Times(b, x)), Power(Times(Plus(Times(b, c), Times(CN1, a, d)), Plus(e, Times(f, x))), -1)))), And(And(And(And(And(FreeQ(List(a, b, c, d, e, f, m, n, p), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), ZeroQ(Plus(m, n, p, C2))), Not(IntegerQ(n))))),
            ISetDelayed(Int(Times(Power(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), m_), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_DEFAULT)), x_Symbol),
                    Condition(Plus(Times(b, Power(Plus(a, Times(b, x)), Plus(m, C1)), Power(Plus(c, Times(d, x)), Plus(n, C1)), Power(Plus(e, Times(f, x)), Plus(p, C1)), Power(Times(Plus(m, C1), Plus(Times(b, c), Times(CN1, a, d)), Plus(Times(b, e), Times(CN1, a, f))), -1)), Times(Power(Times(Plus(m, C1), Plus(Times(b, c), Times(CN1, a, d)), Plus(Times(b, e), Times(CN1, a, f))), -1), Int(Times(Power(Plus(a, Times(b, x)), Plus(m, C1)), Power(Plus(c, Times(d, x)), n), Power(Plus(e, Times(f, x)), p), Simp(Plus(Times(a, d, f, Plus(m, C1)), Times(CN1, b, Plus(Times(d, e, Plus(m, n, C2)), Times(c, f, Plus(m, p, C2)))), Times(CN1, b, d, f, Plus(m, n, p, C3), x)), x)), x))), And(And(And(And(And(And(FreeQ(List(a, b, c, d, e, f, m, n, p), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), NegativeIntegerQ(Plus(m, n, p, C2))), NonzeroQ(Plus(m, C1))), Or(SumSimplerQ(m, C1), And(Not(And(NonzeroQ(Plus(n, C1)), SumSimplerQ(n, C1))), Not(And(NonzeroQ(Plus(p, C1)), SumSimplerQ(p, C1)))))))),
            ISetDelayed(Int(Times(Power(Plus(a_DEFAULT, Times(b_DEFAULT, x_)), m_DEFAULT), Power(Plus(c_DEFAULT, Times(d_DEFAULT, x_)), n_DEFAULT), Power(Plus(e_DEFAULT, Times(f_DEFAULT, x_)), p_DEFAULT)), x_Symbol),
                    Condition(Times(Power(Plus(a, Times(b, x)), Plus(m, C1)), Power(Plus(c, Times(d, x)), n), Power(Plus(e, Times(f, x)), p), Power(Times(b, Plus(m, C1), Power(Times(b, Plus(c, Times(d, x)), Power(Plus(Times(b, c), Times(CN1, a, d)), -1)), n), Power(Times(b, Plus(e, Times(f, x)), Power(Plus(Times(b, e), Times(CN1, a, f)), -1)), p)), -1), AppellF1(Plus(m, C1), Negate(n), Negate(p), Plus(m, C2), Times(CN1, d, Plus(a, Times(b, x)), Power(Plus(Times(b, c), Times(CN1, a, d)), -1)), Times(CN1, f, Plus(a, Times(b, x)), Power(Plus(Times(b, e), Times(CN1, a, f)), -1)))), And(And(And(And(And(FreeQ(List(a, b, c, d, e, f, m, n, p), x), NonzeroQ(Plus(Times(b, c), Times(CN1, a, d)))), NonzeroQ(Plus(Times(b, e), Times(CN1, a, f)))), NonzeroQ(Plus(Times(d, e), Times(CN1, c, f)))), Not(NegativeIntegerQ(m))), Not(PositiveIntegerQ(Plus(p, C1)))))),
            ISetDelayed(Int(Times(Power(Plus(a_DEFAULT, Times(b_DEFAULT, u_)), m_DEFAULT), Power(Plus(c_DEFAULT, Times(d_DEFAULT, v_)), n_DEFAULT), Power(Plus(e_, Times(f_DEFAULT, w_)), p_DEFAULT)), x_Symbol),
                    Condition(Times(Power(Coefficient(u, x, C1), -1), Subst(Int(Times(Power(Plus(a, Times(b, x)), m), Power(Plus(c, Times(d, x)), n), Power(Plus(e, Times(f, x)), p)), x), x, u)), And(And(And(And(FreeQ(List(a, b, c, d, e, f, m, n, p), x), ZeroQ(Plus(u, Negate(v)))), ZeroQ(Plus(u, Negate(w)))), LinearQ(u, x)), NonzeroQ(Plus(u, Negate(x)))))),
            ISetDelayed(Int(Times(Power(u_, m_DEFAULT), Power(v_, n_DEFAULT), Power(w_, p_DEFAULT)), x_Symbol),
                    Condition(Int(Times(Power(ExpandToSum(u, x), m), Power(ExpandToSum(v, x), n), Power(ExpandToSum(w, x), p)), x), And(And(FreeQ(List(m, n, p), x), LinearQ(List(u, v, w), x)), Not(LinearMatchQ(List(u, v, w), x)))))
    );
}
