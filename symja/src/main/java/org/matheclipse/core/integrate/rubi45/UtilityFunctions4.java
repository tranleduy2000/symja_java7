package org.matheclipse.core.integrate.rubi45;


import static org.matheclipse.core.expression.F.*;
import static org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors.*;

import org.matheclipse.core.interfaces.IAST;
/** 
 * UtilityFunctions rules from the <a href="http://www.apmaths.uwo.ca/~arich/">Rubi -
 * rule-based integrator</a>.
 *  
 */
public class UtilityFunctions4 { 
  public static IAST RULES = List( 
ISetDelayed(ExpandLinearProduct(v_,u_,a_,b_,x_Symbol),
    Condition(Module(List($s("lst")),CompoundExpression(CompoundExpression(Set($s("lst"),CoefficientList(ReplaceAll(u,Rule(x,Times(Plus(x,Negate(a)),Power(b,-1)))),x)),Set($s("lst"),Map(Function(SimplifyTerm(Slot1,x)),$s("lst")))),Sum(Times(v,Part($s("lst"),k),Power(Plus(a,Times(b,x)),Plus(k,Negate(C1)))),List(k,C1,Length($s("lst")))))),And(FreeQ(List(a,b),x),PolynomialQ(u,x)))),
ISetDelayed(ExpandTrigExpand(u_,F_,v_,m_,n_,x_Symbol),
    Module(List(Set(w,ReplaceAll(Expand(Power(TrigExpand(F(Times(n,x))),m),x),Rule(x,v)))),If(SumQ(w),Map(Function(Times(u,Slot1)),w),Times(u,w)))),
ISetDelayed(ExpandTrigReduce(u_,v_,x_Symbol),
    Module(List(Set(w,ExpandTrigReduce(v,x))),If(SumQ(w),Map(Function(Times(u,Slot1)),w),Times(u,w)))),
ISetDelayed(ExpandTrigReduce(Times(u_DEFAULT,Power($(F_,Plus(n_,v_DEFAULT)),m_DEFAULT)),x_Symbol),
    Condition(Module(List($s("nn")),ReplaceAll(ExpandTrigReduce(Times(u,Power(F(Plus($s("nn"),v)),m)),x),Rule($s("nn"),n))),And(And(MemberQ(List($s("Sinh"),$s("Cosh")),FSymbol),IntegerQ(m)),RationalQ(n)))),
ISetDelayed(ExpandTrigReduce(u_,x_Symbol),
    ExpandTrigReduceAux(u,x)),
ISetDelayed(ExpandTrigReduceAux(u_,x_Symbol),
    Module(List(Set(v,Expand(TrigReduce(u)))),If(SumQ(v),Map(Function(NormalizeTrig(Slot1,x)),v),NormalizeTrig(v,x)))),
ISetDelayed(NormalizeTrig(Times(a_DEFAULT,Power($(F_,u_),n_DEFAULT)),x_Symbol),
    Condition(Times(a,Power(F(ExpandToSum(u,x)),n)),And(And(FreeQ(List(FSymbol,a,n),x),PolynomialQ(u,x)),Greater(Exponent(u,x),C0)))),
ISetDelayed(NormalizeTrig(u_,x_Symbol),
    u),
ISetDelayed(ExpandTrigToExp(u_,x_Symbol),
    ExpandTrigToExp(C1,u,x)),
ISetDelayed(ExpandTrigToExp(u_,v_,x_Symbol),
    Module(List(Set(w,TrigToExp(v))),CompoundExpression(Set(w,If(SumQ(w),Map(Function(SimplifyIntegrand(Times(u,Slot1),x)),w),SimplifyIntegrand(Times(u,w),x))),ExpandIntegrand(FreeFactors(w,x),NonfreeFactors(w,x),x)))),
ISetDelayed(Distrib(u_,v_),
    If(SumQ(v),Map(Function(Times(u,Slot1)),v),Times(u,v))),
ISetDelayed(FunctionOfLinear(u_,x_Symbol),
    Module(List(Set($s("lst"),FunctionOfLinear(u,False,False,x,False))),If(Or(Or(FalseQ($s("lst")),FalseQ(Part($s("lst"),C1))),And(SameQ(Part($s("lst"),C1),C0),SameQ(Part($s("lst"),C2),C1))),False,List(FunctionOfLinearSubst(u,Part($s("lst"),C1),Part($s("lst"),C2),x),Part($s("lst"),C1),Part($s("lst"),C2))))),
ISetDelayed(FunctionOfLinear(u_,a_,b_,x_,$p("flag")),
    If(FreeQ(u,x),List(a,b),If(CalculusQ(u),False,If(LinearQ(u,x),If(FalseQ(a),List(Coefficient(u,x,C0),Coefficient(u,x,C1)),Module(List(Set($s("lst"),CommonFactors(List(b,Coefficient(u,x,C1))))),If(And(ZeroQ(Coefficient(u,x,C0)),Not($s("flag"))),List(C0,Part($s("lst"),C1)),If(ZeroQ(Plus(Times(b,Coefficient(u,x,C0)),Times(CN1,a,Coefficient(u,x,C1)))),List(Times(a,Power(Part($s("lst"),C2),-1)),Part($s("lst"),C1)),List(C0,C1))))),If(And(PowerQ(u),FreeQ(Part(u,C1),x)),FunctionOfLinear(Times(Log(Part(u,C1)),Part(u,C2)),a,b,x,False),Module(List($s("lst")),If(And(ProductQ(u),NonzeroQ(Part(Set($s("lst"),MonomialFactor(u,x)),C1))),If(And(And(And(False,IntegerQ(Part($s("lst"),C1))),Unequal(Part($s("lst"),C1),CN1)),FreeQ(Part($s("lst"),C2),x)),If(And(RationalQ(LeadFactor(Part($s("lst"),C2))),Less(LeadFactor(Part($s("lst"),C2)),C0)),FunctionOfLinear(Times(DivideDegreesOfFactors(Negate(Part($s("lst"),C2)),Part($s("lst"),C1)),x),a,b,x,False),FunctionOfLinear(Times(DivideDegreesOfFactors(Part($s("lst"),C2),Part($s("lst"),C1)),x),a,b,x,False)),False),CompoundExpression(Set($s("lst"),List(a,b)),Catch(CompoundExpression(Scan(Function(CompoundExpression(Set($s("lst"),FunctionOfLinear(Slot1,Part($s("lst"),C1),Part($s("lst"),C2),x,SumQ(u))),If(FalseQ($s("lst")),Throw(False)))),u),$s("lst"))))))))))),
ISetDelayed(FunctionOfLinearSubst(u_,a_,b_,x_),
    If(FreeQ(u,x),u,If(LinearQ(u,x),Module(List(Set($s("tmp"),Coefficient(u,x,C1))),CompoundExpression(Set($s("tmp"),If(SameQ($s("tmp"),b),C1,Times($s("tmp"),Power(b,-1)))),Plus(Coefficient(u,x,C0),Times(CN1,a,$s("tmp")),Times($s("tmp"),x)))),If(And(PowerQ(u),FreeQ(Part(u,C1),x)),Power(E,FullSimplify(FunctionOfLinearSubst(Times(Log(Part(u,C1)),Part(u,C2)),a,b,x))),Module(List($s("lst")),If(And(ProductQ(u),NonzeroQ(Part(Set($s("lst"),MonomialFactor(u,x)),C1))),If(And(RationalQ(LeadFactor(Part($s("lst"),C2))),Less(LeadFactor(Part($s("lst"),C2)),C0)),Negate(Power(FunctionOfLinearSubst(Times(DivideDegreesOfFactors(Negate(Part($s("lst"),C2)),Part($s("lst"),C1)),x),a,b,x),Part($s("lst"),C1))),Power(FunctionOfLinearSubst(Times(DivideDegreesOfFactors(Part($s("lst"),C2),Part($s("lst"),C1)),x),a,b,x),Part($s("lst"),C1))),Map(Function(FunctionOfLinearSubst(Slot1,a,b,x)),u))))))),
ISetDelayed(DivideDegreesOfFactors(u_,n_),
    If(ProductQ(u),Map(Function(Power(LeadBase(Slot1),Times(LeadDegree(Slot1),Power(n,-1)))),u),Power(LeadBase(u),Times(LeadDegree(u),Power(n,-1))))),
ISetDelayed(FunctionOfInverseLinear(u_,x_Symbol),
    FunctionOfInverseLinear(u,Null,x)),
ISetDelayed(FunctionOfInverseLinear(u_,$p("lst"),x_),
    If(FreeQ(u,x),$s("lst"),If(SameQ(u,x),False,If(QuotientOfLinearsQ(u,x),Module(List(Set($s("tmp"),Drop(QuotientOfLinearsParts(u,x),C2))),If(SameQ(Part($s("tmp"),C2),C0),False,If(SameQ($s("lst"),Null),$s("tmp"),If(ZeroQ(Plus(Times(Part($s("lst"),C1),Part($s("tmp"),C2)),Times(CN1,Part($s("lst"),C2),Part($s("tmp"),C1)))),$s("lst"),False)))),If(CalculusQ(u),False,Module(List(Set($s("tmp"),$s("lst"))),Catch(CompoundExpression(Scan(Function(If(FalseQ(Set($s("tmp"),FunctionOfInverseLinear(Slot1,$s("tmp"),x))),Throw(False))),u),$s("tmp"))))))))),
ISetDelayed(FunctionOfExponentialQ(u_,x_Symbol),
    Block(List(Set($s("$base$"),Null),Set($s("$expon$"),Null),Set($s("§$exponflag$"),False)),And(FunctionOfExponentialTest(u,x),$s("§$exponflag$")))),
ISetDelayed(FunctionOfExponential(u_,x_Symbol),
    Block(List(Set($s("$base$"),Null),Set($s("$expon$"),Null),Set($s("§$exponflag$"),False)),CompoundExpression(FunctionOfExponentialTest(u,x),Power($s("$base$"),$s("$expon$"))))),
ISetDelayed(FunctionOfExponentialFunction(u_,x_Symbol),
    Block(List(Set($s("$base$"),Null),Set($s("$expon$"),Null),Set($s("§$exponflag$"),False)),CompoundExpression(FunctionOfExponentialTest(u,x),SimplifyIntegrand(FunctionOfExponentialFunctionAux(u,x),x)))),
ISetDelayed(FunctionOfExponentialFunctionAux(u_,x_),
    If(AtomQ(u),u,If(And(And(PowerQ(u),FreeQ(Part(u,C1),x)),LinearQ(Part(u,C2),x)),If(ZeroQ(Coefficient($s("$expon$"),x,C0)),Times(Power(Part(u,C1),Coefficient(Part(u,C2),x,C0)),Power(x,FullSimplify(Times(Log(Part(u,C1)),Coefficient(Part(u,C2),x,C1),Power(Times(Log($s("$base$")),Coefficient($s("$expon$"),x,C1)),-1))))),Power(x,FullSimplify(Times(Log(Part(u,C1)),Coefficient(Part(u,C2),x,C1),Power(Times(Log($s("$base$")),Coefficient($s("$expon$"),x,C1)),-1))))),If(And(HyperbolicQ(u),LinearQ(Part(u,C1),x)),Module(List($s("tmp")),CompoundExpression(Set($s("tmp"),Power(x,FullSimplify(Times(Coefficient(Part(u,C1),x,C1),Power(Times(Log($s("$base$")),Coefficient($s("$expon$"),x,C1)),-1))))),If(SinhQ(u),Plus(Times(C1D2,$s("tmp")),Negate(Power(Times(C2,$s("tmp")),-1))),If(CoshQ(u),Plus(Times(C1D2,$s("tmp")),Power(Times(C2,$s("tmp")),-1)),If(TanhQ(u),Times(Plus($s("tmp"),Negate(Power($s("tmp"),-1))),Power(Plus($s("tmp"),Power($s("tmp"),-1)),-1)),If(CothQ(u),Times(Plus($s("tmp"),Power($s("tmp"),-1)),Power(Plus($s("tmp"),Negate(Power($s("tmp"),-1))),-1)),If(SechQ(u),Times(C2,Power(Plus($s("tmp"),Power($s("tmp"),-1)),-1)),Times(C2,Power(Plus($s("tmp"),Negate(Power($s("tmp"),-1))),-1))))))))),If(And(And(PowerQ(u),FreeQ(Part(u,C1),x)),SumQ(Part(u,C2))),Times(FunctionOfExponentialFunctionAux(Power(Part(u,C1),First(Part(u,C2))),x),FunctionOfExponentialFunctionAux(Power(Part(u,C1),Rest(Part(u,C2))),x)),Map(Function(FunctionOfExponentialFunctionAux(Slot1,x)),u)))))),
ISetDelayed(FunctionOfExponentialTest(u_,x_),
    If(FreeQ(u,x),True,If(Or(SameQ(u,x),CalculusQ(u)),False,If(And(And(PowerQ(u),FreeQ(Part(u,C1),x)),LinearQ(Part(u,C2),x)),CompoundExpression(Set($s("§$exponflag$"),True),FunctionOfExponentialTestAux(Part(u,C1),Part(u,C2),x)),If(And(HyperbolicQ(u),LinearQ(Part(u,C1),x)),FunctionOfExponentialTestAux(E,Part(u,C1),x),If(And(And(PowerQ(u),FreeQ(Part(u,C1),x)),SumQ(Part(u,C2))),And(FunctionOfExponentialTest(Power(Part(u,C1),First(Part(u,C2))),x),FunctionOfExponentialTest(Power(Part(u,C1),Rest(Part(u,C2))),x)),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfExponentialTest(Slot1,x)),Throw(False))),u),True)))))))),
ISetDelayed(FunctionOfExponentialTestAux($p("base"),$p("expon"),x_),
    If(SameQ($s("$base$"),Null),CompoundExpression(CompoundExpression(Set($s("$base$"),$s("base")),Set($s("$expon$"),$s("expon"))),True),Module(List($s("tmp")),CompoundExpression(Set($s("tmp"),FullSimplify(Times(Log($s("base")),Coefficient($s("expon"),x,C1),Power(Times(Log($s("$base$")),Coefficient($s("$expon$"),x,C1)),-1)))),If(Not(RationalQ($s("tmp"))),False,If(Or(ZeroQ(Coefficient($s("$expon$"),x,C0)),NonzeroQ(Plus($s("tmp"),Negate(FullSimplify(Times(Log($s("base")),Coefficient($s("expon"),x,C0),Power(Times(Log($s("$base$")),Coefficient($s("$expon$"),x,C0)),-1))))))),CompoundExpression(CompoundExpression(If(And(PositiveIntegerQ($s("base"),$s("$base$")),Less($s("base"),$s("$base$"))),CompoundExpression(CompoundExpression(Set($s("$base$"),$s("base")),Set($s("$expon$"),$s("expon"))),Set($s("tmp"),Power($s("tmp"),-1)))),Set($s("$expon$"),Times(Coefficient($s("$expon$"),x,C1),x,Power(Denominator($s("tmp")),-1)))),If(And(Less($s("tmp"),C0),NegQ(Coefficient($s("$expon$"),x,C1))),CompoundExpression(Set($s("$expon$"),Negate($s("$expon$"))),True),True)),CompoundExpression(CompoundExpression(If(And(PositiveIntegerQ($s("base"),$s("$base$")),Less($s("base"),$s("$base$"))),CompoundExpression(CompoundExpression(Set($s("$base$"),$s("base")),Set($s("$expon$"),$s("expon"))),Set($s("tmp"),Power($s("tmp"),-1)))),Set($s("$expon$"),Times($s("$expon$"),Power(Denominator($s("tmp")),-1)))),If(And(Less($s("tmp"),C0),NegQ(Coefficient($s("$expon$"),x,C1))),CompoundExpression(Set($s("$expon$"),Negate($s("$expon$"))),True),True)))))))),
ISetDelayed(FunctionOfTrigOfLinearQ(u_,x_Symbol),
    And(Not(MemberQ(List(Null,False),FunctionOfTrig(u,Null,x))),AlgebraicTrigFunctionQ(u,x))),
ISetDelayed(FunctionOfTrig(u_,x_Symbol),
    Module(List(Set(v,FunctionOfTrig(ActivateTrig(u),Null,x))),If(SameQ(v,Null),False,v))),
ISetDelayed(FunctionOfTrig(u_,v_,x_),
    If(AtomQ(u),If(SameQ(u,x),False,v),If(And(TrigQ(u),LinearQ(Part(u,C1),x)),If(SameQ(v,Null),Part(u,C1),Module(List(Set(a,Coefficient(v,x,C0)),Set(b,Coefficient(v,x,C1)),Set(c,Coefficient(Part(u,C1),x,C0)),Set(d,Coefficient(Part(u,C1),x,C1))),If(And(ZeroQ(Plus(Times(a,d),Times(CN1,b,c))),RationalQ(Times(b,Power(d,-1)))),Plus(Times(a,Power(Numerator(Times(b,Power(d,-1))),-1)),Times(b,x,Power(Numerator(Times(b,Power(d,-1))),-1))),False))),If(And(HyperbolicQ(u),LinearQ(Part(u,C1),x)),If(SameQ(v,Null),Times(CI,Part(u,C1)),Module(List(Set(a,Coefficient(v,x,C0)),Set(b,Coefficient(v,x,C1)),Set(c,Times(CI,Coefficient(Part(u,C1),x,C0))),Set(d,Times(CI,Coefficient(Part(u,C1),x,C1)))),If(And(ZeroQ(Plus(Times(a,d),Times(CN1,b,c))),RationalQ(Times(b,Power(d,-1)))),Plus(Times(a,Power(Numerator(Times(b,Power(d,-1))),-1)),Times(b,x,Power(Numerator(Times(b,Power(d,-1))),-1))),False))),If(CalculusQ(u),False,Module(List(Set(w,v)),Catch(CompoundExpression(Scan(Function(If(FalseQ(Set(w,FunctionOfTrig(Slot1,w,x))),Throw(False))),u),w)))))))),
ISetDelayed(AlgebraicTrigFunctionQ(u_,x_Symbol),
    If(AtomQ(u),True,If(And(TrigQ(u),LinearQ(Part(u,C1),x)),True,If(And(HyperbolicQ(u),LinearQ(Part(u,C1),x)),True,If(And(PowerQ(u),FreeQ(Part(u,C2),x)),AlgebraicTrigFunctionQ(Part(u,C1),x),If(Or(ProductQ(u),SumQ(u)),Catch(CompoundExpression(Scan(Function(If(Not(AlgebraicTrigFunctionQ(Slot1,x)),Throw(False))),u),True)),False)))))),
ISetDelayed(FunctionOfHyperbolic(u_,x_Symbol),
    Module(List(Set(v,FunctionOfHyperbolic(u,Null,x))),If(SameQ(v,Null),False,v))),
ISetDelayed(FunctionOfHyperbolic(u_,v_,x_),
    If(AtomQ(u),If(SameQ(u,x),False,v),If(And(HyperbolicQ(u),LinearQ(Part(u,C1),x)),If(SameQ(v,Null),Part(u,C1),Module(List(Set(a,Coefficient(v,x,C0)),Set(b,Coefficient(v,x,C1)),Set(c,Coefficient(Part(u,C1),x,C0)),Set(d,Coefficient(Part(u,C1),x,C1))),If(And(ZeroQ(Plus(Times(a,d),Times(CN1,b,c))),RationalQ(Times(b,Power(d,-1)))),Plus(Times(a,Power(Numerator(Times(b,Power(d,-1))),-1)),Times(b,x,Power(Numerator(Times(b,Power(d,-1))),-1))),False))),If(CalculusQ(u),False,Module(List(Set(w,v)),Catch(CompoundExpression(Scan(Function(If(FalseQ(Set(w,FunctionOfHyperbolic(Slot1,w,x))),Throw(False))),u),w))))))),
ISetDelayed(FunctionOfQ(v_,u_,x_Symbol),
    If(FreeQ(u,x),False,If(AtomQ(v),True,If(Not(InertTrigFreeQ(u)),FunctionOfQ(v,ActivateTrig(u),x,False),If(And(ProductQ(v),Not(OneQ(FreeFactors(v,x)))),FunctionOfQ(NonfreeFactors(v,x),u,x,False),If(Or(SinQ(v),CscQ(v)),FunctionOfSinQ(u,Part(v,C1),x),If(Or(CosQ(v),SecQ(v)),FunctionOfCosQ(u,Part(v,C1),x),If(Or(TanQ(v),CotQ(v)),FunctionOfTanQ(u,Part(v,C1),x),If(Or(SinhQ(v),CschQ(v)),FunctionOfSinhQ(u,Part(v,C1),x),If(Or(CoshQ(v),SechQ(v)),FunctionOfCoshQ(u,Part(v,C1),x),If(Or(TanhQ(v),CothQ(v)),FunctionOfTanhQ(u,Part(v,C1),x),UnsameQ(FunctionOfExpnQ(u,v,x),False)))))))))))),
ISetDelayed(FunctionOfQ(v_,u_,x_Symbol,$p("§pureflag")),
    If(FreeQ(u,x),False,If(AtomQ(v),True,If(Not(InertTrigFreeQ(u)),FunctionOfQ(v,ActivateTrig(u),x,$s("§pureflag")),If(And(ProductQ(v),Not(OneQ(FreeFactors(v,x)))),FunctionOfQ(NonfreeFactors(v,x),u,x,$s("§pureflag")),If($s("§pureflag"),If(Or(SinQ(v),CscQ(v)),PureFunctionOfSinQ(u,Part(v,C1),x),If(Or(CosQ(v),SecQ(v)),PureFunctionOfCosQ(u,Part(v,C1),x),If(TanQ(v),PureFunctionOfTanQ(u,Part(v,C1),x),If(CotQ(v),PureFunctionOfCotQ(u,Part(v,C1),x),If(Or(SinhQ(v),CschQ(v)),PureFunctionOfSinhQ(u,Part(v,C1),x),If(Or(CoshQ(v),SechQ(v)),PureFunctionOfCoshQ(u,Part(v,C1),x),If(TanhQ(v),PureFunctionOfTanhQ(u,Part(v,C1),x),If(CothQ(v),PureFunctionOfCothQ(u,Part(v,C1),x),UnsameQ(FunctionOfExpnQ(u,v,x),False))))))))),If(Or(SinQ(v),CscQ(v)),FunctionOfSinQ(u,Part(v,C1),x),If(Or(CosQ(v),SecQ(v)),FunctionOfCosQ(u,Part(v,C1),x),If(Or(TanQ(v),CotQ(v)),FunctionOfTanQ(u,Part(v,C1),x),If(Or(SinhQ(v),CschQ(v)),FunctionOfSinhQ(u,Part(v,C1),x),If(Or(CoshQ(v),SechQ(v)),FunctionOfCoshQ(u,Part(v,C1),x),If(Or(TanhQ(v),CothQ(v)),FunctionOfTanhQ(u,Part(v,C1),x),UnsameQ(FunctionOfExpnQ(u,v,x),False))))))))))))),
ISetDelayed(FunctionOfExpnQ(u_,v_,x_),
    If(SameQ(u,v),C1,If(AtomQ(u),If(SameQ(u,x),False,C0),If(CalculusQ(u),False,If(And(PowerQ(u),FreeQ(Part(u,C2),x)),If(ZeroQ(Plus(Part(u,C1),Negate(v))),If(IntegerQ(Part(u,C2)),Part(u,C2),C1),If(And(And(PowerQ(v),FreeQ(Part(v,C2),x)),ZeroQ(Plus(Part(u,C1),Negate(Part(v,C1))))),If(RationalQ(Part(v,C2)),If(And(And(RationalQ(Part(u,C2)),IntegerQ(Times(Part(u,C2),Power(Part(v,C2),-1)))),Or(Greater(Part(v,C2),C0),Less(Part(u,C2),C0))),Times(Part(u,C2),Power(Part(v,C2),-1)),False),If(IntegerQ(Simplify(Times(Part(u,C2),Power(Part(v,C2),-1)))),Simplify(Times(Part(u,C2),Power(Part(v,C2),-1))),False)),FunctionOfExpnQ(Part(u,C1),v,x))),If(And(ProductQ(u),Not(OneQ(FreeFactors(u,x)))),FunctionOfExpnQ(NonfreeFactors(u,x),v,x),If(And(ProductQ(u),ProductQ(v)),Module(List(Set($s("deg1"),FunctionOfExpnQ(First(u),First(v),x)),$s("deg2")),If(SameQ($s("deg1"),False),False,CompoundExpression(Set($s("deg2"),FunctionOfExpnQ(Rest(u),Rest(v),x)),If(And(SameQ($s("deg1"),$s("deg2")),FreeQ(Simplify(Times(u,Power(Power(v,$s("deg1")),-1))),x)),$s("deg1"),False)))),Module(List(Set($s("lst"),Map(Function(FunctionOfExpnQ(Slot1,v,x)),Apply($s("List"),u)))),If(MemberQ($s("lst"),False),False,Apply($s("Integrate::Gcd"),$s("lst"))))))))))),
ISetDelayed(PureFunctionOfSinQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(TrigQ(u),ZeroQ(Plus(Part(u,C1),Negate(v)))),Or(SinQ(u),CscQ(u)),Catch(CompoundExpression(Scan(Function(If(Not(PureFunctionOfSinQ(Slot1,v,x)),Throw(False))),u),True)))))),
ISetDelayed(PureFunctionOfCosQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(TrigQ(u),ZeroQ(Plus(Part(u,C1),Negate(v)))),Or(CosQ(u),SecQ(u)),Catch(CompoundExpression(Scan(Function(If(Not(PureFunctionOfCosQ(Slot1,v,x)),Throw(False))),u),True)))))),
ISetDelayed(PureFunctionOfTanQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(TrigQ(u),ZeroQ(Plus(Part(u,C1),Negate(v)))),Or(TanQ(u),CotQ(u)),Catch(CompoundExpression(Scan(Function(If(Not(PureFunctionOfTanQ(Slot1,v,x)),Throw(False))),u),True)))))),
ISetDelayed(PureFunctionOfCotQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(TrigQ(u),ZeroQ(Plus(Part(u,C1),Negate(v)))),CotQ(u),Catch(CompoundExpression(Scan(Function(If(Not(PureFunctionOfCotQ(Slot1,v,x)),Throw(False))),u),True)))))),
ISetDelayed(FunctionOfSinQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(TrigQ(u),IntegerQuotientQ(Part(u,C1),v)),If(OddQuotientQ(Part(u,C1),v),Or(SinQ(u),CscQ(u)),Or(CosQ(u),SecQ(u))),If(And(And(IntegerPowerQ(u),TrigQ(Part(u,C1))),IntegerQuotientQ(Part(u,C1,C1),v)),If(EvenQ(Part(u,C2)),True,FunctionOfSinQ(Part(u,C1),v,x)),If(ProductQ(u),If(And(And(And(CosQ(Part(u,C1)),SinQ(Part(u,C2))),ZeroQ(Plus(Part(u,C1,C1),Times(CN1,C1D2,v)))),ZeroQ(Plus(Part(u,C2,C1),Times(CN1,C1D2,v)))),FunctionOfSinQ(Drop(u,C2),v,x),Module(List($s("lst")),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Sin"),$s("Csc"),u,v,False)),If(And(NotFalseQ($s("lst")),EvenQuotientQ(Part($s("lst"),C1),v)),FunctionOfSinQ(Times(Cos(v),Part($s("lst"),C2)),v,x),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Cos"),$s("Sec"),u,v,False)),If(And(NotFalseQ($s("lst")),OddQuotientQ(Part($s("lst"),C1),v)),FunctionOfSinQ(Times(Cos(v),Part($s("lst"),C2)),v,x),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Tan"),$s("Cot"),u,v,True)),If(NotFalseQ($s("lst")),FunctionOfSinQ(Times(Cos(v),Part($s("lst"),C2)),v,x),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfSinQ(Slot1,v,x)),Throw(False))),u),True)))))))))),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfSinQ(Slot1,v,x)),Throw(False))),u),True)))))))),
ISetDelayed(FunctionOfCosQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(TrigQ(u),IntegerQuotientQ(Part(u,C1),v)),Or(CosQ(u),SecQ(u)),If(And(And(IntegerPowerQ(u),TrigQ(Part(u,C1))),IntegerQuotientQ(Part(u,C1,C1),v)),If(EvenQ(Part(u,C2)),True,FunctionOfCosQ(Part(u,C1),v,x)),If(ProductQ(u),Module(List($s("lst")),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Sin"),$s("Csc"),u,v,False)),If(NotFalseQ($s("lst")),FunctionOfCosQ(Times(Sin(v),Part($s("lst"),C2)),v,x),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Tan"),$s("Cot"),u,v,True)),If(NotFalseQ($s("lst")),FunctionOfCosQ(Times(Sin(v),Part($s("lst"),C2)),v,x),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfCosQ(Slot1,v,x)),Throw(False))),u),True))))))),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfCosQ(Slot1,v,x)),Throw(False))),u),True)))))))),
ISetDelayed(FunctionOfTanQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(TrigQ(u),IntegerQuotientQ(Part(u,C1),v)),Or(Or(TanQ(u),CotQ(u)),EvenQuotientQ(Part(u,C1),v)),If(And(And(And(PowerQ(u),EvenQ(Part(u,C2))),TrigQ(Part(u,C1))),IntegerQuotientQ(Part(u,C1,C1),v)),True,If(And(And(PowerQ(u),EvenQ(Part(u,C2))),SumQ(Part(u,C1))),FunctionOfTanQ(Expand(Sqr(Part(u,C1))),v,x),If(ProductQ(u),Module(List(Set($s("lst"),ReapList(Scan(Function(If(Not(FunctionOfTanQ(Slot1,v,x)),Sow(Slot1))),u)))),If(SameQ($s("lst"),List()),True,And(And(Equal(Length($s("lst")),C2),OddTrigPowerQ(Part($s("lst"),C1),v,x)),OddTrigPowerQ(Part($s("lst"),C2),v,x)))),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfTanQ(Slot1,v,x)),Throw(False))),u),True))))))))),
ISetDelayed(OddTrigPowerQ(u_,v_,x_),
    If(Or(Or(Or(SinQ(u),CosQ(u)),SecQ(u)),CscQ(u)),OddQuotientQ(Part(u,C1),v),If(PowerQ(u),And(OddQ(Part(u,C2)),OddTrigPowerQ(Part(u,C1),v,x)),If(ProductQ(u),If(Not(OneQ(FreeFactors(u,x))),OddTrigPowerQ(NonfreeFactors(u,x),v,x),Module(List(Set($s("lst"),ReapList(Scan(Function(If(Not(FunctionOfTanQ(Slot1,v,x)),Sow(Slot1))),u)))),If(SameQ($s("lst"),List()),True,And(Equal(Length($s("lst")),C1),OddTrigPowerQ(Part($s("lst"),C1),v,x))))),If(SumQ(u),Catch(CompoundExpression(Scan(Function(If(Not(OddTrigPowerQ(Slot1,v,x)),Throw(False))),u),True)),False))))),
ISetDelayed(FunctionOfTanWeight(u_,v_,x_),
    If(AtomQ(u),C0,If(CalculusQ(u),C0,If(And(TrigQ(u),IntegerQuotientQ(Part(u,C1),v)),If(And(TanQ(u),ZeroQ(Plus(Part(u,C1),Negate(v)))),C1,If(And(CotQ(u),ZeroQ(Plus(Part(u,C1),Negate(v)))),CN1,C0)),If(And(And(And(PowerQ(u),EvenQ(Part(u,C2))),TrigQ(Part(u,C1))),IntegerQuotientQ(Part(u,C1,C1),v)),If(Or(Or(TanQ(Part(u,C1)),CosQ(Part(u,C1))),SecQ(Part(u,C1))),C1,CN1),If(ProductQ(u),If(Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfTanQ(Slot1,v,x)),Throw(False))),u),True)),Apply(Plus,Map(Function(FunctionOfTanWeight(Slot1,v,x)),Apply($s("List"),u))),C0),Apply(Plus,Map(Function(FunctionOfTanWeight(Slot1,v,x)),Apply($s("List"),u))))))))),
ISetDelayed(FunctionOfTrigQ(u_,v_,x_Symbol),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(TrigQ(u),IntegerQuotientQ(Part(u,C1),v)),True,Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfTrigQ(Slot1,v,x)),Throw(False))),u),True)))))),
ISetDelayed(PureFunctionOfSinhQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(HyperbolicQ(u),ZeroQ(Plus(Part(u,C1),Negate(v)))),Or(SinhQ(u),CschQ(u)),Catch(CompoundExpression(Scan(Function(If(Not(PureFunctionOfSinhQ(Slot1,v,x)),Throw(False))),u),True)))))),
ISetDelayed(PureFunctionOfCoshQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(HyperbolicQ(u),ZeroQ(Plus(Part(u,C1),Negate(v)))),Or(CoshQ(u),SechQ(u)),Catch(CompoundExpression(Scan(Function(If(Not(PureFunctionOfCoshQ(Slot1,v,x)),Throw(False))),u),True)))))),
ISetDelayed(PureFunctionOfTanhQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(HyperbolicQ(u),ZeroQ(Plus(Part(u,C1),Negate(v)))),Or(TanhQ(u),CothQ(u)),Catch(CompoundExpression(Scan(Function(If(Not(PureFunctionOfTanhQ(Slot1,v,x)),Throw(False))),u),True)))))),
ISetDelayed(PureFunctionOfCothQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(HyperbolicQ(u),ZeroQ(Plus(Part(u,C1),Negate(v)))),CothQ(u),Catch(CompoundExpression(Scan(Function(If(Not(PureFunctionOfCothQ(Slot1,v,x)),Throw(False))),u),True)))))),
ISetDelayed(FunctionOfSinhQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(HyperbolicQ(u),IntegerQuotientQ(Part(u,C1),v)),If(OddQuotientQ(Part(u,C1),v),Or(SinhQ(u),CschQ(u)),Or(CoshQ(u),SechQ(u))),If(And(And(IntegerPowerQ(u),HyperbolicQ(Part(u,C1))),IntegerQuotientQ(Part(u,C1,C1),v)),If(EvenQ(Part(u,C2)),True,FunctionOfSinhQ(Part(u,C1),v,x)),If(ProductQ(u),If(And(And(And(CoshQ(Part(u,C1)),SinhQ(Part(u,C2))),ZeroQ(Plus(Part(u,C1,C1),Times(CN1,C1D2,v)))),ZeroQ(Plus(Part(u,C2,C1),Times(CN1,C1D2,v)))),FunctionOfSinhQ(Drop(u,C2),v,x),Module(List($s("lst")),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Sinh"),$s("Csch"),u,v,False)),If(And(NotFalseQ($s("lst")),EvenQuotientQ(Part($s("lst"),C1),v)),FunctionOfSinhQ(Times(Cosh(v),Part($s("lst"),C2)),v,x),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Cosh"),$s("Sech"),u,v,False)),If(And(NotFalseQ($s("lst")),OddQuotientQ(Part($s("lst"),C1),v)),FunctionOfSinhQ(Times(Cosh(v),Part($s("lst"),C2)),v,x),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Tanh"),$s("Coth"),u,v,True)),If(NotFalseQ($s("lst")),FunctionOfSinhQ(Times(Cosh(v),Part($s("lst"),C2)),v,x),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfSinhQ(Slot1,v,x)),Throw(False))),u),True)))))))))),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfSinhQ(Slot1,v,x)),Throw(False))),u),True)))))))),
ISetDelayed(FunctionOfCoshQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(HyperbolicQ(u),IntegerQuotientQ(Part(u,C1),v)),Or(CoshQ(u),SechQ(u)),If(And(And(IntegerPowerQ(u),HyperbolicQ(Part(u,C1))),IntegerQuotientQ(Part(u,C1,C1),v)),If(EvenQ(Part(u,C2)),True,FunctionOfCoshQ(Part(u,C1),v,x)),If(ProductQ(u),Module(List($s("lst")),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Sinh"),$s("Csch"),u,v,False)),If(NotFalseQ($s("lst")),FunctionOfCoshQ(Times(Sinh(v),Part($s("lst"),C2)),v,x),CompoundExpression(Set($s("lst"),FindTrigFactor($s("Tanh"),$s("Coth"),u,v,True)),If(NotFalseQ($s("lst")),FunctionOfCoshQ(Times(Sinh(v),Part($s("lst"),C2)),v,x),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfCoshQ(Slot1,v,x)),Throw(False))),u),True))))))),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfCoshQ(Slot1,v,x)),Throw(False))),u),True)))))))),
ISetDelayed(FunctionOfTanhQ(u_,v_,x_),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(HyperbolicQ(u),IntegerQuotientQ(Part(u,C1),v)),Or(Or(TanhQ(u),CothQ(u)),EvenQuotientQ(Part(u,C1),v)),If(And(And(And(PowerQ(u),EvenQ(Part(u,C2))),HyperbolicQ(Part(u,C1))),IntegerQuotientQ(Part(u,C1,C1),v)),True,If(And(And(PowerQ(u),EvenQ(Part(u,C2))),SumQ(Part(u,C1))),FunctionOfTanhQ(Expand(Sqr(Part(u,C1))),v,x),If(ProductQ(u),Module(List(Set($s("lst"),ReapList(Scan(Function(If(Not(FunctionOfTanhQ(Slot1,v,x)),Sow(Slot1))),u)))),If(SameQ($s("lst"),List()),True,And(And(Equal(Length($s("lst")),C2),OddHyperbolicPowerQ(Part($s("lst"),C1),v,x)),OddHyperbolicPowerQ(Part($s("lst"),C2),v,x)))),Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfTanhQ(Slot1,v,x)),Throw(False))),u),True))))))))),
ISetDelayed(OddHyperbolicPowerQ(u_,v_,x_),
    If(Or(Or(Or(SinhQ(u),CoshQ(u)),SechQ(u)),CschQ(u)),OddQuotientQ(Part(u,C1),v),If(PowerQ(u),And(OddQ(Part(u,C2)),OddHyperbolicPowerQ(Part(u,C1),v,x)),If(ProductQ(u),If(Not(OneQ(FreeFactors(u,x))),OddHyperbolicPowerQ(NonfreeFactors(u,x),v,x),Module(List(Set($s("lst"),ReapList(Scan(Function(If(Not(FunctionOfTanhQ(Slot1,v,x)),Sow(Slot1))),u)))),If(SameQ($s("lst"),List()),True,And(Equal(Length($s("lst")),C1),OddHyperbolicPowerQ(Part($s("lst"),C1),v,x))))),If(SumQ(u),Catch(CompoundExpression(Scan(Function(If(Not(OddHyperbolicPowerQ(Slot1,v,x)),Throw(False))),u),True)),False))))),
ISetDelayed(FunctionOfTanhWeight(u_,v_,x_),
    If(AtomQ(u),C0,If(CalculusQ(u),C0,If(And(HyperbolicQ(u),IntegerQuotientQ(Part(u,C1),v)),If(And(TanhQ(u),ZeroQ(Plus(Part(u,C1),Negate(v)))),C1,If(And(CothQ(u),ZeroQ(Plus(Part(u,C1),Negate(v)))),CN1,C0)),If(And(And(And(PowerQ(u),EvenQ(Part(u,C2))),HyperbolicQ(Part(u,C1))),IntegerQuotientQ(Part(u,C1,C1),v)),If(Or(Or(TanhQ(Part(u,C1)),CoshQ(Part(u,C1))),SechQ(Part(u,C1))),C1,CN1),If(ProductQ(u),If(Catch(CompoundExpression(Scan(Function(If(Not(FunctionOfTanhQ(Slot1,v,x)),Throw(False))),u),True)),Apply(Plus,Map(Function(FunctionOfTanhWeight(Slot1,v,x)),Apply($s("List"),u))),C0),Apply(Plus,Map(Function(FunctionOfTanhWeight(Slot1,v,x)),Apply($s("List"),u))))))))),
ISetDelayed(FunctionOfHyperbolicQ(u_,v_,x_Symbol),
    If(AtomQ(u),UnsameQ(u,x),If(CalculusQ(u),False,If(And(HyperbolicQ(u),IntegerQuotientQ(Part(u,C1),v)),True,Catch(CompoundExpression(Scan(Function(If(FunctionOfHyperbolicQ(Slot1,v,x),Null,Throw(False))),u),True)))))),
ISetDelayed(FindTrigFactor($p("func1"),$p("func2"),u_,v_,$p("flag")),
    If(SameQ(u,C1),False,If(And(And(And(Or(SameQ(Head(LeadBase(u)),$s("func1")),SameQ(Head(LeadBase(u)),$s("func2"))),OddQ(LeadDegree(u))),IntegerQuotientQ(Part(LeadBase(u),C1),v)),Or($s("flag"),NonzeroQ(Plus(Part(LeadBase(u),C1),Negate(v))))),List(Part(LeadBase(u),C1),RemainingFactors(u)),Module(List(Set($s("lst"),FindTrigFactor($s("func1"),$s("func2"),RemainingFactors(u),v,$s("flag")))),If(FalseQ($s("lst")),False,List(Part($s("lst"),C1),Times(LeadFactor(u),Part($s("lst"),C2)))))))),
ISetDelayed(IntegerQuotientQ(u_,v_),
    IntegerQ(Simplify(Times(u,Power(v,-1))))),
ISetDelayed(OddQuotientQ(u_,v_),
    OddQ(Simplify(Times(u,Power(v,-1))))),
ISetDelayed(EvenQuotientQ(u_,v_),
    EvenQ(Simplify(Times(u,Power(v,-1))))),
ISetDelayed(FunctionOfDensePolynomialsQ(u_,x_Symbol),
    If(FreeQ(u,x),True,If(PolynomialQ(u,x),Greater(Length(Exponent(u,x,$s("List"))),C1),Catch(CompoundExpression(Scan(Function(If(FunctionOfDensePolynomialsQ(Slot1,x),Null,Throw(False))),u),True))))),
ISetDelayed(FunctionOfLog(u_,x_Symbol),
    Module(List(Set($s("lst"),FunctionOfLog(u,False,False,x))),If(Or(FalseQ($s("lst")),FalseQ(Part($s("lst"),C2))),False,$s("lst")))),
ISetDelayed(FunctionOfLog(u_,v_,n_,x_),
    If(AtomQ(u),If(SameQ(u,x),False,List(u,v,n)),If(CalculusQ(u),False,Module(List($s("lst")),If(And(And(LogQ(u),NotFalseQ(Set($s("lst"),BinomialTest(Part(u,C1),x)))),ZeroQ(Part($s("lst"),C1))),If(Or(FalseQ(v),SameQ(Part(u,C1),v)),List(x,Part(u,C1),Part($s("lst"),C3)),False),CompoundExpression(Set($s("lst"),List(C0,v,n)),Catch(List(Map(Function(CompoundExpression(Set($s("lst"),FunctionOfLog(Slot1,Part($s("lst"),C2),Part($s("lst"),C3),x)),If(FalseQ($s("lst")),Throw(False),Part($s("lst"),C1)))),u),Part($s("lst"),C2),Part($s("lst"),C3))))))))),
ISetDelayed(PowerVariableExpn(u_,m_,x_Symbol),
    If(IntegerQ(m),Module(List(Set($s("lst"),PowerVariableDegree(u,m,C1,x))),If(FalseQ($s("lst")),False,List(Times(Power(x,Times(m,Power(Part($s("lst"),C1),-1))),PowerVariableSubst(u,Part($s("lst"),C1),x)),Part($s("lst"),C1),Part($s("lst"),C2)))),False)),
ISetDelayed(PowerVariableDegree(u_,m_,c_,x_Symbol),
    If(FreeQ(u,x),List(m,c),If(Or(AtomQ(u),CalculusQ(u)),False,If(And(PowerQ(u),FreeQ(Times(Part(u,C1),Power(x,-1)),x)),If(Or(ZeroQ(m),And(SameQ(m,Part(u,C2)),SameQ(c,Times(Part(u,C1),Power(x,-1))))),List(Part(u,C2),Times(Part(u,C1),Power(x,-1))),If(And(And(And(IntegerQ(Part(u,C2)),IntegerQ(m)),Greater(GCD(m,Part(u,C2)),C1)),SameQ(c,Times(Part(u,C1),Power(x,-1)))),List(GCD(m,Part(u,C2)),c),False)),Catch(Module(List(Set($s("lst"),List(m,c))),CompoundExpression(Scan(Function(CompoundExpression(Set($s("lst"),PowerVariableDegree(Slot1,Part($s("lst"),C1),Part($s("lst"),C2),x)),If(FalseQ($s("lst")),Throw(False)))),u),$s("lst")))))))),
ISetDelayed(PowerVariableSubst(u_,m_,x_Symbol),
    If(Or(Or(FreeQ(u,x),AtomQ(u)),CalculusQ(u)),u,If(And(PowerQ(u),FreeQ(Times(Part(u,C1),Power(x,-1)),x)),Power(x,Times(Part(u,C2),Power(m,-1))),Map(Function(PowerVariableSubst(Slot1,m,x)),u)))),
ISetDelayed(EulerIntegrandQ(Power(Plus(Times(a_DEFAULT,x_),Times(b_DEFAULT,Power(u_,n_))),p_),x_Symbol),
    Condition(True,And(And(And(FreeQ(List(a,b),x),IntegerQ(Plus(n,C1D2))),QuadraticQ(u,x)),Or(Not(RationalQ(p)),And(NegativeIntegerQ(p),Not(BinomialQ(u,x))))))),
ISetDelayed(EulerIntegrandQ(Times(Power(v_,m_DEFAULT),Power(Plus(Times(a_DEFAULT,x_),Times(b_DEFAULT,Power(u_,n_))),p_)),x_Symbol),
    Condition(True,And(And(And(And(FreeQ(List(a,b),x),ZeroQ(Plus(u,Negate(v)))),IntegersQ(Times(C2,m),Plus(n,C1D2))),QuadraticQ(u,x)),Or(Not(RationalQ(p)),And(NegativeIntegerQ(p),Not(BinomialQ(u,x))))))),
ISetDelayed(EulerIntegrandQ(Times(Power(v_,m_DEFAULT),Power(Plus(Times(a_DEFAULT,x_),Times(b_DEFAULT,Power(u_,n_))),p_)),x_Symbol),
    Condition(True,And(And(And(And(FreeQ(List(a,b),x),ZeroQ(Plus(u,Negate(v)))),IntegersQ(Times(C2,m),Plus(n,C1D2))),QuadraticQ(u,x)),Or(Not(RationalQ(p)),And(NegativeIntegerQ(p),Not(BinomialQ(u,x))))))),
ISetDelayed(EulerIntegrandQ(Times(Power(u_,n_),Power(v_,p_)),x_Symbol),
    Condition(True,And(And(And(And(NegativeIntegerQ(p),IntegerQ(Plus(n,C1D2))),QuadraticQ(u,x)),QuadraticQ(v,x)),Not(BinomialQ(v,x))))),
ISetDelayed(EulerIntegrandQ(u_,x_Symbol),
    False),
ISetDelayed(FunctionOfSquareRootOfQuadratic(u_,x_Symbol),
    If(MatchQ(u,Condition(Times(Power(x,m_DEFAULT),Power(Plus(a_,Times(b_DEFAULT,Power(x,n_DEFAULT))),p_)),FreeQ(List(a,b,m,n,p),x))),False,Module(List(Set($s("tmp"),FunctionOfSquareRootOfQuadratic(u,False,x))),If(Or(FalseQ($s("tmp")),FalseQ(Part($s("tmp"),C1))),False,CompoundExpression(Set($s("tmp"),Part($s("tmp"),C1)),Module(List(Set(a,Coefficient($s("tmp"),x,C0)),Set(b,Coefficient($s("tmp"),x,C1)),Set(c,Coefficient($s("tmp"),x,C2)),$s("§sqrt"),q,r),If(Or(And(ZeroQ(a),ZeroQ(b)),ZeroQ(Plus(Sqr(b),Times(CN1,C4,a,c)))),False,If(PosQ(c),CompoundExpression(CompoundExpression(CompoundExpression(Set($s("§sqrt"),Rt(c,C2)),Set(q,Plus(Times(a,$s("§sqrt")),Times(b,x),Times($s("§sqrt"),Sqr(x))))),Set(r,Plus(b,Times(C2,$s("§sqrt"),x)))),List(Simplify(Times(SquareRootOfQuadraticSubst(u,Times(q,Power(r,-1)),Times(Plus(Negate(a),Sqr(x)),Power(r,-1)),x),q,Power(r,-2))),Simplify(Plus(Times($s("§sqrt"),x),Sqrt($s("tmp")))),C2)),If(PosQ(a),CompoundExpression(CompoundExpression(CompoundExpression(Set($s("§sqrt"),Rt(a,C2)),Set(q,Plus(Times(c,$s("§sqrt")),Times(CN1,b,x),Times($s("§sqrt"),Sqr(x))))),Set(r,Plus(c,Negate(Sqr(x))))),List(Simplify(Times(SquareRootOfQuadraticSubst(u,Times(q,Power(r,-1)),Times(Plus(Negate(b),Times(C2,$s("§sqrt"),x)),Power(r,-1)),x),q,Power(r,-2))),Simplify(Times(Plus(Negate($s("§sqrt")),Sqrt($s("tmp"))),Power(x,-1))),C1)),CompoundExpression(CompoundExpression(Set($s("§sqrt"),Rt(Plus(Sqr(b),Times(CN1,C4,a,c)),C2)),Set(r,Plus(c,Negate(Sqr(x))))),List(Simplify(Times(CN1,$s("§sqrt"),SquareRootOfQuadraticSubst(u,Times(CN1,$s("§sqrt"),x,Power(r,-1)),Times(CN1,Plus(Times(b,c),Times(c,$s("§sqrt")),Times(Plus(Negate(b),$s("§sqrt")),Sqr(x))),Power(Times(C2,c,r),-1)),x),x,Power(r,-2))),FullSimplify(Times(C2,c,Sqrt($s("tmp")),Power(Plus(b,Negate($s("§sqrt")),Times(C2,c,x)),-1))),C3))))))))))),
ISetDelayed(FunctionOfSquareRootOfQuadratic(u_,v_,x_Symbol),
    If(Or(AtomQ(u),FreeQ(u,x)),List(v),If(And(PowerQ(u),FreeQ(Part(u,C2),x)),If(And(And(And(FractionQ(Part(u,C2)),Equal(Denominator(Part(u,C2)),C2)),PolynomialQ(Part(u,C1),x)),Equal(Exponent(Part(u,C1),x),C2)),If(Or(FalseQ(v),SameQ(Part(u,C1),v)),List(Part(u,C1)),False),FunctionOfSquareRootOfQuadratic(Part(u,C1),v,x)),If(Or(ProductQ(u),SumQ(u)),Catch(Module(List(Set($s("lst"),List(v))),CompoundExpression(Scan(Function(CompoundExpression(Set($s("lst"),FunctionOfSquareRootOfQuadratic(Slot1,Part($s("lst"),C1),x)),If(FalseQ($s("lst")),Throw(False)))),u),$s("lst")))),False)))),
ISetDelayed(SquareRootOfQuadraticSubst(u_,$p("vv"),$p("xx"),x_Symbol),
    If(Or(AtomQ(u),FreeQ(u,x)),If(SameQ(u,x),$s("xx"),u),If(And(PowerQ(u),FreeQ(Part(u,C2),x)),If(And(And(And(FractionQ(Part(u,C2)),Equal(Denominator(Part(u,C2)),C2)),PolynomialQ(Part(u,C1),x)),Equal(Exponent(Part(u,C1),x),C2)),Power($s("vv"),Numerator(Part(u,C2))),Power(SquareRootOfQuadraticSubst(Part(u,C1),$s("vv"),$s("xx"),x),Part(u,C2))),Map(Function(SquareRootOfQuadraticSubst(Slot1,$s("vv"),$s("xx"),x)),u)))),
ISetDelayed(Subst(u_,x_Symbol,w_),
    SimplifyAntiderivative(SubstAux(u,x,w),x)),
ISetDelayed(Subst(u_,x_,w_),
    SubstAux(u,x,w)),
ISetDelayed(SubstAux(Plus(a_,Times(b_DEFAULT,x_)),x_Symbol,Times(c_DEFAULT,Sqr($(F_,z_)))),
    Condition(Times(a,Simplify(Plus(C1,Negate(Sqr(F(z)))))),And(And(FreeQ(List(a,b,c),x),MemberQ(List($s("Sin"),$s("Cos"),$s("Sec"),$s("Csc"),$s("Cosh"),$s("Tanh"),$s("Coth"),$s("Sech")),FSymbol)),ZeroQ(Plus(a,Times(b,c)))))),
ISetDelayed(SubstAux(Plus(a_,Times(b_DEFAULT,x_)),x_Symbol,Times(c_DEFAULT,Sqr($(F_,z_)))),
    Condition(Times(a,Simplify(Plus(C1,Sqr(F(z))))),And(And(FreeQ(List(a,b,c),x),MemberQ(List($s("Tan"),$s("Cot"),$s("Sinh"),$s("Csch")),FSymbol)),ZeroQ(Plus(a,Times(CN1,b,c)))))),
ISetDelayed(SubstAux(Plus(a_,Times(b_DEFAULT,Sqr(x_))),x_Symbol,Times(c_DEFAULT,$(F_,z_))),
    Condition(Times(a,Simplify(Plus(C1,Negate(Sqr(F(z)))))),And(And(FreeQ(List(a,b,c),x),MemberQ(List($s("Sin"),$s("Cos"),$s("Sec"),$s("Csc"),$s("Cosh"),$s("Tanh"),$s("Coth"),$s("Sech")),FSymbol)),ZeroQ(Plus(a,Times(b,Sqr(c))))))),
ISetDelayed(SubstAux(Plus(a_,Times(b_DEFAULT,Sqr(x_))),x_Symbol,Times(c_DEFAULT,$(F_,z_))),
    Condition(Times(a,Simplify(Plus(C1,Sqr(F(z))))),And(And(FreeQ(List(a,b,c),x),MemberQ(List($s("Tan"),$s("Cot"),$s("Sinh"),$s("Csch")),FSymbol)),ZeroQ(Plus(a,Times(CN1,b,Sqr(c))))))),
ISetDelayed(SubstAux($(F_,Times(a_DEFAULT,Power(x_,m_DEFAULT))),x_Symbol,Times(b_DEFAULT,Power(x_,n_))),
    Condition($(Part(Extract(List($s("ArcCsc"),$s("ArcSec"),$s("ArcCot"),$s("ArcTan"),$s("ArcCos"),$s("ArcSin"),$s("ArcCsch"),$s("ArcSech"),$s("ArcCoth"),$s("ArcTanh"),$s("ArcCosh"),$s("ArcSinh")),Position(List($s("ArcSin"),$s("ArcCos"),$s("ArcTan"),$s("ArcCot"),$s("ArcSec"),$s("ArcCsc"),$s("ArcSinh"),$s("ArcCosh"),$s("ArcTanh"),$s("ArcCoth"),$s("ArcSech"),$s("ArcCsch")),FSymbol)),C1),Times(Power(x,Times(CN1,m,n)),Power(Times(a,Power(b,m)),-1))),And(And(And(FreeQ(List(a,b),x),PositiveIntegerQ(m)),NegativeIntegerQ(n)),MemberQ(List($s("ArcSin"),$s("ArcCos"),$s("ArcTan"),$s("ArcCot"),$s("ArcSec"),$s("ArcCsc"),$s("ArcSinh"),$s("ArcCosh"),$s("ArcTanh"),$s("ArcCoth"),$s("ArcSech"),$s("ArcCsch")),FSymbol)))),
ISetDelayed(SubstAux(u_,v_,w_),
    If(SameQ(u,v),w,If(AtomQ(u),u,If(PowerQ(u),If(And(And(PowerQ(v),SameQ(Part(u,C1),Part(v,C1))),SumQ(Part(u,C2))),Times(SubstAux(Power(Part(u,C1),First(Part(u,C2))),v,w),SubstAux(Power(Part(u,C1),Rest(Part(u,C2))),v,w)),Power(SubstAux(Part(u,C1),v,w),SubstAux(Part(u,C2),v,w))),If(SameQ(Head(u),Defer($s("Integrate::Subst"))),If(Or(SameQ(Part(u,C2),v),FreeQ(Part(u,C1),v)),SubstAux(Part(u,C1),Part(u,C2),SubstAux(Part(u,C3),v,w)),$(Defer($s("Integrate::Subst")),u,v,w)),If(SameQ(Head(u),Defer($s("Integrate::Dist"))),$(Defer($s("Integrate::Dist")),SubstAux(Part(u,C1),v,w),SubstAux(Part(u,C2),v,w),Part(u,C3)),If(Or(And(CalculusQ(u),Not(FreeQ(v,Part(u,C2)))),And(HeldFormQ(u),UnsameQ(Head(u),Defer($s("AppellF1"))))),$(Defer($s("Integrate::Subst")),u,v,w),Map(Function(SubstAux(Slot1,v,w)),u)))))))),
ISetDelayed(SimplifyAntiderivative(Times(c_,u_),x_Symbol),
    Condition(Module(List(Set(v,SimplifyAntiderivative(u,x))),If(And(SumQ(v),NonsumQ(u)),Map(Function(Times(c,Slot1)),v),Times(c,v))),FreeQ(c,x))),
ISetDelayed(SimplifyAntiderivative(Log(Times(c_,u_)),x_Symbol),
    Condition(SimplifyAntiderivative(Log(u),x),FreeQ(c,x))),
ISetDelayed(SimplifyAntiderivative(Log(Power(u_,n_)),x_Symbol),
    Condition(Times(n,SimplifyAntiderivative(Log(u),x)),FreeQ(n,x))),
ISetDelayed(SimplifyAntiderivative($(F_,$(G_,u_)),x_Symbol),
    Condition(Negate(SimplifyAntiderivative(F(Power(G(u),-1)),x)),And(MemberQ(List($s("Log"),$s("ArcTan"),$s("ArcCot")),FSymbol),MemberQ(List($s("Cot"),$s("Sec"),$s("Csc"),$s("Coth"),$s("Sech"),$s("Csch")),GSymbol)))),
ISetDelayed(SimplifyAntiderivative($(F_,$(G_,u_)),x_Symbol),
    Condition(SimplifyAntiderivative(F(Power(G(u),-1)),x),And(MemberQ(List($s("ArcTanh"),$s("ArcCoth")),FSymbol),MemberQ(List($s("Cot"),$s("Sec"),$s("Csc"),$s("Coth"),$s("Sech"),$s("Csch")),GSymbol)))),
ISetDelayed(SimplifyAntiderivative(Log($(F_,u_)),x_Symbol),
    Condition(Negate(SimplifyAntiderivative(Log(Power(F(u),-1)),x)),MemberQ(List($s("Cot"),$s("Sec"),$s("Csc"),$s("Coth"),$s("Sech"),$s("Csch")),FSymbol))),
ISetDelayed(SimplifyAntiderivative(Log(Power(f_,u_)),x_Symbol),
    Condition(Times(Log(f),SimplifyAntiderivative(u,x)),FreeQ(f,x))),
ISetDelayed(SimplifyAntiderivative(Log(Plus(a_,Times(b_DEFAULT,Tan(u_)))),x_Symbol),
    Condition(Plus(Times(b,Power(a,-1),SimplifyAntiderivative(u,x)),Negate(SimplifyAntiderivative(Log(Cos(u)),x))),And(FreeQ(List(a,b),x),ZeroQ(Plus(Sqr(a),Sqr(b)))))),
ISetDelayed(SimplifyAntiderivative(Log(Plus(a_,Times(b_DEFAULT,Cot(u_)))),x_Symbol),
    Condition(Plus(Times(CN1,b,Power(a,-1),SimplifyAntiderivative(u,x)),Negate(SimplifyAntiderivative(Log(Sin(u)),x))),And(FreeQ(List(a,b),x),ZeroQ(Plus(Sqr(a),Sqr(b)))))),
ISetDelayed(SimplifyAntiderivative(ArcTan(Times(a_DEFAULT,Tan(u_))),x_Symbol),
    Condition(RectifyTangent(u,a,C1,x),And(And(FreeQ(a,x),PositiveQ(Sqr(a))),ComplexFreeQ(u)))),
ISetDelayed(SimplifyAntiderivative(ArcCot(Times(a_DEFAULT,Tan(u_))),x_Symbol),
    Condition(RectifyTangent(u,a,CN1,x),And(And(FreeQ(a,x),PositiveQ(Sqr(a))),ComplexFreeQ(u)))),
ISetDelayed(SimplifyAntiderivative(ArcCot(Times(a_DEFAULT,Tanh(u_))),x_Symbol),
    Condition(Negate(SimplifyAntiderivative(ArcTan(Times(a,Tanh(u))),x)),And(FreeQ(a,x),ComplexFreeQ(u))))
  );
}
